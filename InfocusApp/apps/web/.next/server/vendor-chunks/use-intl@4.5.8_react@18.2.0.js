"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl@4.5.8_react@18.2.0";
exports.ids = ["vendor-chunks/use-intl@4.5.8_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(ssr)/../../node_modules/.pnpm/intl-messageformat@10.7.18/node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/../../node_modules/.pnpm/@formatjs+fast-memoize@2.2.7/node_modules/@formatjs/fast-memoize/lib/index.js\");\n\n\n\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nvar IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}(IntlErrorCode || {});\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n    const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n    const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n    const dateTimeFormats = {\n        ...globalFormats?.dateTime,\n        ...inlineFormats?.dateTime\n    };\n    const allFormats = {\n        date: {\n            ...mfDateDefaults,\n            ...dateTimeFormats\n        },\n        time: {\n            ...mfTimeDefaults,\n            ...dateTimeFormats\n        },\n        number: {\n            ...globalFormats?.number,\n            ...inlineFormats?.number\n        }\n    };\n    if (timeZone) {\n        // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n        // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n        [\n            \"date\",\n            \"time\"\n        ].forEach((property)=>{\n            const formats = allFormats[property];\n            for (const [key, value] of Object.entries(formats)){\n                formats[key] = {\n                    timeZone,\n                    ...value\n                };\n            }\n        });\n    }\n    return allFormats;\n}\nfunction joinPath(...parts) {\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction createCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {}\n    };\n}\nfunction createMemoCache(store) {\n    return {\n        create () {\n            return {\n                get (key) {\n                    return store[key];\n                },\n                set (key, value) {\n                    store[key] = value;\n                }\n            };\n        }\n    };\n}\nfunction memoFn(fn, cache) {\n    return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n        cache: createMemoCache(cache),\n        strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n    });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n    return memoFn((...args)=>new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n    const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n    const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n    const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n    const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n    const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n    const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n    return {\n        getDateTimeFormat,\n        getNumberFormat,\n        getPluralRules,\n        getRelativeTimeFormat,\n        getListFormat,\n        getDisplayNames\n    };\n}\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n    const getMessageFormat = memoFn((...args)=>new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], {\n            formatters: intlFormatters,\n            ...args[3]\n        }), cache.message);\n    return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(`No messages available at \\`${namespace}\\`.`);\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (part == null || next == null) {\n            throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    try {\n        if (!messages) {\n            throw new Error(`No messages were configured.`);\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!retrievedMessages) {\n            throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    // To improve runtime performance, only compile message if:\n    return(// 1. Values are provided\n    values || // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) || // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n     : candidate // Don't compile\n    );\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl({ cache, formats: globalFormats, formatters, getMessageFallback = defaultGetMessageFallback, locale, messagesOrError, namespace, onError, timeZone }) {\n    const hasMessagesError = messagesOrError instanceof IntlError;\n    function getFallbackFromErrorAndNotify(key, code, message, fallback) {\n        const error = new IntlError(code, message);\n        onError(error);\n        return fallback ?? getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats, _fallback) {\n        const fallback = _fallback;\n        let message;\n        if (hasMessagesError) {\n            if (fallback) {\n                message = fallback;\n            } else {\n                onError(messagesOrError);\n                return getMessageFallback({\n                    error: messagesOrError,\n                    key,\n                    namespace\n                });\n            }\n        } else {\n            const messages = messagesOrError;\n            try {\n                message = resolvePath(locale, messages, key, namespace);\n            } catch (error) {\n                if (fallback) {\n                    message = fallback;\n                } else {\n                    return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message, fallback);\n                }\n            }\n        }\n        if (typeof message === \"object\") {\n            let code, errorMessage;\n            if (Array.isArray(message)) {\n                code = IntlErrorCode.INVALID_MESSAGE;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/translations#arrays-of-messages`;\n                }\n            } else {\n                code = IntlErrorCode.INSUFFICIENT_PATH;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/translations#structuring-messages`;\n                }\n            }\n            return getFallbackFromErrorAndNotify(key, code, errorMessage);\n        }\n        let messageFormat;\n        // Hot path that avoids creating an `IntlMessageFormat` instance\n        const plainMessage = getPlainMessage(message, values);\n        if (plainMessage) return plainMessage;\n        // Lazy init the message formatter for better tree\n        // shaking in case message formatting is not used.\n        if (!formatters.getMessageFormat) {\n            formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n        }\n        try {\n            messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n                formatters: {\n                    ...formatters,\n                    getDateTimeFormat (locales, options) {\n                        // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                        return formatters.getDateTimeFormat(locales, {\n                            timeZone,\n                            ...options\n                        });\n                    }\n                }\n            });\n        } catch (error) {\n            const thrownError = error;\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? ` (${thrownError.originalMessage})` : \"\"), fallback);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            values ? prepareTranslationValues(values) : values);\n            if (formattedMessage == null) {\n                throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"}`);\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message, fallback);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Custom formats for numbers, dates and times. */ formats, _fallback) {\n        const result = translateBaseFn(key, values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats, _fallback)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (hasMessagesError) {\n            onError(messagesOrError);\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    translateFn.has = (key)=>{\n        if (hasMessagesError) {\n            return false;\n        }\n        try {\n            resolvePath(locale, messagesOrError, key, namespace);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n    const { _cache: cache = createCache(), _formatters: formatters = createIntlFormatters(cache), formats, locale, onError = defaultOnError, timeZone: globalTimeZone } = props;\n    function applyTimeZone(options) {\n        if (!options?.timeZone) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats?.[formatName];\n            if (!options) {\n                const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        if (overrides) {\n            options = {\n                ...options,\n                ...overrides\n            };\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n        } catch  {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(start, end, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.number, (options)=>formatters.getNumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        // Only read when necessary to avoid triggering a `dynamicIO` error\n        // unnecessarily (`now` is only needed for `format.relativeTime`)\n        if (props.now) {\n            return props.now;\n        } else {\n            onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n            return new Date();\n        }\n    }\n    function relativeTime(date, nowOrOptions) {\n        try {\n            let nowDate, unit;\n            const opts = {};\n            if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n                nowDate = new Date(nowOrOptions);\n            } else if (nowOrOptions) {\n                if (nowOrOptions.now != null) {\n                    nowDate = new Date(nowOrOptions.now);\n                } else {\n                    nowDate = getGlobalNow();\n                }\n                unit = nowOrOptions.unit;\n                opts.style = nowOrOptions.style;\n                // @ts-expect-error -- Types are slightly outdated\n                opts.numberingSystem = nowOrOptions.numberingSystem;\n            }\n            if (!nowDate) {\n                nowDate = getGlobalNow();\n            }\n            const dateDate = new Date(date);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            if (!unit) {\n                unit = resolveRelativeTimeUnit(seconds);\n            }\n            // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n            // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n            // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n            // not desired, as the given dates might cross a threshold were the\n            // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n            // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n            // case. By using `always` we can ensure correct output. The only exception\n            // is the formatting of times <1 second as \"now\".\n            opts.numeric = unit === \"second\" ? \"auto\" : \"always\";\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions, overrides) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, overrides, formats?.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach(([key, messageOrMessages])=>{\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += ` (at ${parentPath})`;\n            invalidKeyLabels.push(keyLabel);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? \"key\" : \"keys\"}: ${invalidKeyLabels.join(\", \")}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig({ formats, getMessageFallback, messages, onError, ...rest }) {\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        formats: formats || undefined,\n        messages: messages || undefined,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VzZS1pbnRsQDQuNS44X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1DSURWTVMyRS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxrQkFBa0JDO0lBQ3RCQyxZQUFZQyxJQUFJLEVBQUVDLGVBQWUsQ0FBRTtRQUNqQyxJQUFJQyxVQUFVRjtRQUNkLElBQUlDLGlCQUFpQjtZQUNuQkMsV0FBVyxPQUFPRDtRQUNwQjtRQUNBLEtBQUssQ0FBQ0M7UUFDTixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJQyxpQkFBaUI7WUFDbkIsSUFBSSxDQUFDQSxlQUFlLEdBQUdBO1FBQ3pCO0lBQ0Y7QUFDRjtBQUVBLElBQUlFLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFvQixHQUFHO0lBQ3JDQSxhQUFhLENBQUMsa0JBQWtCLEdBQUc7SUFDbkNBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxtQkFBbUIsR0FBRztJQUNwQyxPQUFPQTtBQUNULEVBQUVBLGlCQUFpQixDQUFDO0FBRXBCOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGtDQUFrQ0MsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLFFBQVE7SUFDL0UsTUFBTUMsaUJBQWlCaEIsaUVBQWlCQSxDQUFDaUIsT0FBTyxDQUFDQyxJQUFJO0lBQ3JELE1BQU1DLGlCQUFpQm5CLGlFQUFpQkEsQ0FBQ2lCLE9BQU8sQ0FBQ0csSUFBSTtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEIsR0FBR1IsZUFBZVMsUUFBUTtR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Q3BCcEIsVUFBVUEsWUFBWW9CO1FBQ3RCTSxTQUFTK0c7UUFDVGhILG9CQUFvQmlIO0lBQ3RCO0FBQ0Y7QUFFK08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VzZS1pbnRsQDQuNS44X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1DSURWTVMyRS5qcz9hZTUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludGxNZXNzYWdlRm9ybWF0IH0gZnJvbSAnaW50bC1tZXNzYWdlZm9ybWF0JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50LCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtZW1vaXplLCBzdHJhdGVnaWVzIH0gZnJvbSAnQGZvcm1hdGpzL2Zhc3QtbWVtb2l6ZSc7XG5cbmNsYXNzIEludGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgb3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2UgKz0gJzogJyArIG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIEludGxFcnJvckNvZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEludGxFcnJvckNvZGUpIHtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfTUVTU0FHRVwiXSA9IFwiTUlTU0lOR19NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX0ZPUk1BVFwiXSA9IFwiTUlTU0lOR19GT1JNQVRcIjtcbiAgSW50bEVycm9yQ29kZVtcIkVOVklST05NRU5UX0ZBTExCQUNLXCJdID0gXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX1BBVEhcIl0gPSBcIklOU1VGRklDSUVOVF9QQVRIXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX01FU1NBR0VcIl0gPSBcIklOVkFMSURfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9LRVlcIl0gPSBcIklOVkFMSURfS0VZXCI7XG4gIEludGxFcnJvckNvZGVbXCJGT1JNQVRUSU5HX0VSUk9SXCJdID0gXCJGT1JNQVRUSU5HX0VSUk9SXCI7XG4gIHJldHVybiBJbnRsRXJyb3JDb2RlO1xufShJbnRsRXJyb3JDb2RlIHx8IHt9KTtcblxuLyoqXG4gKiBgaW50bC1tZXNzYWdlZm9ybWF0YCB1c2VzIHNlcGFyYXRlIGtleXMgZm9yIGBkYXRlYCBhbmQgYHRpbWVgLCBidXQgdGhlcmUnc1xuICogb25seSBvbmUgbmF0aXZlIEFQSTogYEludGwuRGF0ZVRpbWVGb3JtYXRgLiBBZGRpdGlvbmFsbHkgeW91IG1pZ2h0IHdhbnQgdG9cbiAqIGluY2x1ZGUgYm90aCBhIHRpbWUgYW5kIGEgZGF0ZSBpbiBhIHZhbHVlLCB0aGVyZWZvcmUgdGhlIHNlcGFyYXRpb24gZG9lc24ndFxuICogc2VlbSBzbyB1c2VmdWwuIFdlIG9mZmVyIGEgc2luZ2xlIGBkYXRlVGltZWAgbmFtZXNwYWNlIGluc3RlYWQsIGJ1dCB3ZSBoYXZlXG4gKiB0byBjb252ZXJ0IHRoZSBmb3JtYXQgYmVmb3JlIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGNhbiBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoZ2xvYmFsRm9ybWF0cywgaW5saW5lRm9ybWF0cywgdGltZVpvbmUpIHtcbiAgY29uc3QgbWZEYXRlRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdC5mb3JtYXRzLmRhdGU7XG4gIGNvbnN0IG1mVGltZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXQuZm9ybWF0cy50aW1lO1xuICBjb25zdCBkYXRlVGltZUZvcm1hdHMgPSB7XG4gICAgLi4uZ2xvYmFsRm9ybWF0cz8uZGF0ZVRpbWUsXG4gICAgLi4uaW5saW5lRm9ybWF0cz8uZGF0ZVRpbWVcbiAgfTtcbiAgY29uc3QgYWxsRm9ybWF0cyA9IHtcbiAgICBkYXRlOiB7XG4gICAgICAuLi5tZkRhdGVEZWZhdWx0cyxcbiAgICAgIC4uLmRhdGVUaW1lRm9ybWF0c1xuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgLi4ubWZUaW1lRGVmYXVsdHMsXG4gICAgICAuLi5kYXRlVGltZUZvcm1hdHNcbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgLi4uZ2xvYmFsRm9ybWF0cz8ubnVtYmVyLFxuICAgICAgLi4uaW5saW5lRm9ybWF0cz8ubnVtYmVyXG4gICAgfVxuICAgIC8vIChsaXN0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUNVIG1lc3NhZ2VzKVxuICB9O1xuICBpZiAodGltZVpvbmUpIHtcbiAgICAvLyBUaGUgb25seSB3YXkgdG8gc2V0IGEgdGltZSB6b25lIHdpdGggYGludGwtbWVzc2FnZWZvcm1hdGAgaXMgdG8gbWVyZ2UgaXQgaW50byB0aGUgZm9ybWF0c1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9ibG9iLzgyNTZjNTI3MTUwNWNmMjYwNmU0OGUzYzk3ZWNkZDE2ZWRlNGYxYjUvcGFja2FnZXMvaW50bC9zcmMvbWVzc2FnZS50cyNMMTVcbiAgICBbJ2RhdGUnLCAndGltZSddLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IGFsbEZvcm1hdHNbcHJvcGVydHldO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZm9ybWF0cykpIHtcbiAgICAgICAgZm9ybWF0c1trZXldID0ge1xuICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFsbEZvcm1hdHM7XG59XG5cbmZ1bmN0aW9uIGpvaW5QYXRoKC4uLnBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoQm9vbGVhbikuam9pbignLicpO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGRlZmF1bHRzIHRoYXQgYXJlIHVzZWQgZm9yIGFsbCBlbnRyeSBwb2ludHMgaW50byB0aGUgY29yZS5cbiAqIFNlZSBhbHNvIGBJbml0aWFsaXplZEludGxDb25maWd1cmF0aW9uYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrKHByb3BzKSB7XG4gIHJldHVybiBqb2luUGF0aChwcm9wcy5uYW1lc3BhY2UsIHByb3BzLmtleSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWU6IHt9LFxuICAgIG51bWJlcjoge30sXG4gICAgbWVzc2FnZToge30sXG4gICAgcmVsYXRpdmVUaW1lOiB7fSxcbiAgICBwbHVyYWxSdWxlczoge30sXG4gICAgbGlzdDoge30sXG4gICAgZGlzcGxheU5hbWVzOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTWVtb0NhY2hlKHN0b3JlKSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgIHJldHVybiBzdG9yZVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtZW1vRm4oZm4sIGNhY2hlKSB7XG4gIHJldHVybiBtZW1vaXplKGZuLCB7XG4gICAgY2FjaGU6IGNyZWF0ZU1lbW9DYWNoZShjYWNoZSksXG4gICAgc3RyYXRlZ3k6IHN0cmF0ZWdpZXMudmFyaWFkaWNcbiAgfSk7XG59XG5mdW5jdGlvbiBtZW1vQ29uc3RydWN0b3IoQ29uc3RydWN0b3JGbiwgY2FjaGUpIHtcbiAgcmV0dXJuIG1lbW9GbigoLi4uYXJncykgPT4gbmV3IENvbnN0cnVjdG9yRm4oLi4uYXJncyksIGNhY2hlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSB7XG4gIGNvbnN0IGdldERhdGVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuRGF0ZVRpbWVGb3JtYXQsIGNhY2hlLmRhdGVUaW1lKTtcbiAgY29uc3QgZ2V0TnVtYmVyRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTnVtYmVyRm9ybWF0LCBjYWNoZS5udW1iZXIpO1xuICBjb25zdCBnZXRQbHVyYWxSdWxlcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLlBsdXJhbFJ1bGVzLCBjYWNoZS5wbHVyYWxSdWxlcyk7XG4gIGNvbnN0IGdldFJlbGF0aXZlVGltZUZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLlJlbGF0aXZlVGltZUZvcm1hdCwgY2FjaGUucmVsYXRpdmVUaW1lKTtcbiAgY29uc3QgZ2V0TGlzdEZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkxpc3RGb3JtYXQsIGNhY2hlLmxpc3QpO1xuICBjb25zdCBnZXREaXNwbGF5TmFtZXMgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EaXNwbGF5TmFtZXMsIGNhY2hlLmRpc3BsYXlOYW1lcyk7XG4gIHJldHVybiB7XG4gICAgZ2V0RGF0ZVRpbWVGb3JtYXQsXG4gICAgZ2V0TnVtYmVyRm9ybWF0LFxuICAgIGdldFBsdXJhbFJ1bGVzLFxuICAgIGdldFJlbGF0aXZlVGltZUZvcm1hdCxcbiAgICBnZXRMaXN0Rm9ybWF0LFxuICAgIGdldERpc3BsYXlOYW1lc1xuICB9O1xufVxuXG4vLyBQbGFjZWQgaGVyZSBmb3IgaW1wcm92ZWQgdHJlZSBzaGFraW5nLiBTb21laG93IHdoZW4gdGhpcyBpcyBwbGFjZWQgaW5cbi8vIGBmb3JtYXR0ZXJzLnRzeGAsIHRoZW4gaXQgY2FuJ3QgYmUgc2hha2VuIG9mZiBmcm9tIGBuZXh0LWludGxgLlxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUZvcm1hdHRlcihjYWNoZSwgaW50bEZvcm1hdHRlcnMpIHtcbiAgY29uc3QgZ2V0TWVzc2FnZUZvcm1hdCA9IG1lbW9GbigoLi4uYXJncykgPT4gbmV3IEludGxNZXNzYWdlRm9ybWF0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIHtcbiAgICBmb3JtYXR0ZXJzOiBpbnRsRm9ybWF0dGVycyxcbiAgICAuLi5hcmdzWzNdXG4gIH0pLCBjYWNoZS5tZXNzYWdlKTtcbiAgcmV0dXJuIGdldE1lc3NhZ2VGb3JtYXQ7XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSkge1xuICBjb25zdCBmdWxsS2V5ID0gam9pblBhdGgobmFtZXNwYWNlLCBrZXkpO1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyBhdmFpbGFibGUgYXQgXFxgJHtuYW1lc3BhY2V9XFxgLmAgKTtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzO1xuICBrZXkuc3BsaXQoJy4nKS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBtZXNzYWdlW3BhcnRdO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAocGFydCA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBcXGAke2Z1bGxLZXl9XFxgIGluIG1lc3NhZ2VzIGZvciBsb2NhbGUgXFxgJHtsb2NhbGV9XFxgLmAgKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG5leHQ7XG4gIH0pO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIHtcbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy8xNDY3XG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWVzID0ge307XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICBsZXQgdHJhbnNmb3JtZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNmb3JtZWQgPSBjaHVua3MgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZShjaHVua3MpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KHJlc3VsdCkgPyAvKiNfX1BVUkVfXyovY2xvbmVFbGVtZW50KHJlc3VsdCwge1xuICAgICAgICAgIGtleToga2V5ICsgaW5kZXgrK1xuICAgICAgICB9KSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gdmFsdWU7XG4gICAgfVxuICAgIHRyYW5zZm9ybWVkVmFsdWVzW2tleV0gPSB0cmFuc2Zvcm1lZDtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzT3JFcnJvcihsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIHdlcmUgY29uZmlndXJlZC5gICk7XG4gICAgfVxuICAgIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gbmFtZXNwYWNlID8gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSA6IG1lc3NhZ2VzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIGZvciBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgIGZvdW5kLmAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHJpZXZlZE1lc3NhZ2VzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGludGxFcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICAvLyBUbyBpbXByb3ZlIHJ1bnRpbWUgcGVyZm9ybWFuY2UsIG9ubHkgY29tcGlsZSBtZXNzYWdlIGlmOlxuICByZXR1cm4gKFxuICAgIC8vIDEuIFZhbHVlcyBhcmUgcHJvdmlkZWRcbiAgICB2YWx1ZXMgfHxcbiAgICAvLyAyLiBUaGVyZSBhcmUgZXNjYXBlZCBicmFjZXMgKGUuZy4gXCIne25hbWUnfVwiKVxuICAgIC8nW3t9XS8udGVzdChjYW5kaWRhdGUpIHx8XG4gICAgLy8gMy4gVGhlcmUgYXJlIG1pc3NpbmcgYXJndW1lbnRzIG9yIHRhZ3MgKGRldi1vbmx5IGVycm9yIGhhbmRsaW5nKVxuICAgIC88fHsvLnRlc3QoY2FuZGlkYXRlKSA/IHVuZGVmaW5lZCAvLyBDb21waWxlXG4gICAgOiBjYW5kaWRhdGUgLy8gRG9uJ3QgY29tcGlsZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3IoY29uZmlnKSB7XG4gIGNvbnN0IG1lc3NhZ2VzT3JFcnJvciA9IGdldE1lc3NhZ2VzT3JFcnJvcihjb25maWcubG9jYWxlLCBjb25maWcubWVzc2FnZXMsIGNvbmZpZy5uYW1lc3BhY2UpO1xuICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5jb25maWcsXG4gICAgbWVzc2FnZXNPckVycm9yXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgY2FjaGUsXG4gIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gIGZvcm1hdHRlcnMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayA9IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gIGxvY2FsZSxcbiAgbWVzc2FnZXNPckVycm9yLFxuICBuYW1lc3BhY2UsXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IGhhc01lc3NhZ2VzRXJyb3IgPSBtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBJbnRsRXJyb3I7XG4gIGZ1bmN0aW9uIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgbWVzc2FnZSwgZmFsbGJhY2spIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoY29kZSwgbWVzc2FnZSk7XG4gICAgb25FcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGZhbGxiYWNrID8/IGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICBlcnJvcixcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUJhc2VGbigvKiogVXNlIGEgZG90IHRvIGluZGljYXRlIGEgbGV2ZWwgb2YgbmVzdGluZyAoZS5nLiBgbmFtZXNwYWNlLm5lc3RlZExhYmVsYCkuICovXG4gIGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgLyoqIFByb3ZpZGUgY3VzdG9tIGZvcm1hdHMgZm9yIG51bWJlcnMsIGRhdGVzIGFuZCB0aW1lcy4gKi9cbiAgZm9ybWF0cywgX2ZhbGxiYWNrKSB7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBfZmFsbGJhY2s7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICBtZXNzYWdlID0gZmFsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVycm9yKG1lc3NhZ2VzT3JFcnJvcik7XG4gICAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGZhbGxiYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlLCBmYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgbGV0IGNvZGUsIGVycm9yTWVzc2FnZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgIGNvZGUgPSBJbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRTtcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBNZXNzYWdlIGF0IFxcYCR7am9pblBhdGgobmFtZXNwYWNlLCBrZXkpfVxcYCByZXNvbHZlZCB0byBhbiBhcnJheSwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvdHJhbnNsYXRpb25zI2FycmF5cy1vZi1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgPSBJbnRsRXJyb3JDb2RlLklOU1VGRklDSUVOVF9QQVRIO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBcXGAuXFxgIHRvIHJldHJpZXZlIG5lc3RlZCBtZXNzYWdlcy4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL3RyYW5zbGF0aW9ucyNzdHJ1Y3R1cmluZy1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuXG4gICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG5cbiAgICAvLyBMYXp5IGluaXQgdGhlIG1lc3NhZ2UgZm9ybWF0dGVyIGZvciBiZXR0ZXIgdHJlZVxuICAgIC8vIHNoYWtpbmcgaW4gY2FzZSBtZXNzYWdlIGZvcm1hdHRpbmcgaXMgbm90IHVzZWQuXG4gICAgaWYgKCFmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCA9IGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGZvcm1hdHRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBmb3JtYXRzLCB0aW1lWm9uZSksIHtcbiAgICAgICAgZm9ybWF0dGVyczoge1xuICAgICAgICAgIC4uLmZvcm1hdHRlcnMsXG4gICAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy80Mjc5XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB0aHJvd25FcnJvciA9IGVycm9yO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIHRocm93bkVycm9yLm1lc3NhZ2UgKyAoJ29yaWdpbmFsTWVzc2FnZScgaW4gdGhyb3duRXJyb3IgPyBgICgke3Rocm93bkVycm9yLm9yaWdpbmFsTWVzc2FnZX0pYCA6ICcnKSAsIGZhbGxiYWNrKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSBtZXNzYWdlRm9ybWF0LmZvcm1hdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGludGwtbWVzc2FnZWZvcm1hdGAgZXhwZWN0cyBhIGRpZmZlcmVudCBmb3JtYXRcbiAgICAgIC8vIGZvciByaWNoIHRleHQgZWxlbWVudHMgc2luY2UgYSByZWNlbnQgbWlub3IgdXBkYXRlLiBUaGlzXG4gICAgICAvLyBuZWVkcyB0byBiZSBldmFsdWF0ZWQgaW4gZGV0YWlsLCBwb3NzaWJseSBhbHNvIGluIHJlZ2FyZHNcbiAgICAgIC8vIHRvIGJlIGFibGUgdG8gZm9ybWF0IHRvIHBhcnRzLlxuICAgICAgdmFsdWVzID8gcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHZhbHVlcykgOiB2YWx1ZXMpO1xuICAgICAgaWYgKGZvcm1hdHRlZE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmb3JtYXQgXFxgJHtrZXl9XFxgIGluICR7bmFtZXNwYWNlID8gYG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGBgIDogJ21lc3NhZ2VzJ31gICk7XG4gICAgICB9XG5cbiAgICAgIC8vIExpbWl0IHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgdG8gcmV0dXJuIHN0cmluZ3Mgb3IgUmVhY3QgZWxlbWVudHNcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQoZm9ybWF0dGVkTWVzc2FnZSkgfHxcbiAgICAgIC8vIEFycmF5cyBvZiBSZWFjdCBlbGVtZW50c1xuICAgICAgQXJyYXkuaXNBcnJheShmb3JtYXR0ZWRNZXNzYWdlKSB8fCB0eXBlb2YgZm9ybWF0dGVkTWVzc2FnZSA9PT0gJ3N0cmluZycgPyBmb3JtYXR0ZWRNZXNzYWdlIDogU3RyaW5nKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UsIGZhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBDdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzLCBfZmFsbGJhY2spIHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LCB2YWx1ZXMsIGZvcm1hdHMsIF9mYWxsYmFjayk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgYFRoZSBtZXNzYWdlIFxcYCR7a2V5fVxcYCBpbiAke25hbWVzcGFjZSA/IGBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgYCA6ICdtZXNzYWdlcyd9IGRpZG4ndCByZXNvbHZlIHRvIGEgc3RyaW5nLiBJZiB5b3Ugd2FudCB0byBmb3JtYXQgcmljaCB0ZXh0LCB1c2UgXFxgdC5yaWNoXFxgIGluc3RlYWQuYCApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyYW5zbGF0ZUZuLnJpY2ggPSB0cmFuc2xhdGVCYXNlRm47XG5cbiAgLy8gQXVnbWVudCBgdHJhbnNsYXRlQmFzZUZuYCB0byByZXR1cm4gcGxhaW4gc3RyaW5nc1xuICB0cmFuc2xhdGVGbi5tYXJrdXAgPSAoa2V5LCB2YWx1ZXMsIGZvcm1hdHMsIF9mYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgTWFya3VwVHJhbnNsYXRpb25WYWx1ZXNgIGlzIHByYWN0aWNhbGx5IGEgc3ViIHR5cGVcbiAgICAvLyBvZiBgUmljaFRyYW5zbGF0aW9uVmFsdWVzYCBidXQgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggaGVyZS5cbiAgICB2YWx1ZXMsIGZvcm1hdHMsIF9mYWxsYmFjayk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBcImB0Lm1hcmt1cGAgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGF0IHJlY2VpdmUgYW5kIHJldHVybiBzdHJpbmdzLlxcblxcbkUuZy4gdC5tYXJrdXAoJ21hcmt1cCcsIHtiOiAoY2h1bmtzKSA9PiBgPGI+JHtjaHVua3N9PC9iPmB9KVwiKTtcbiAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHRyYW5zbGF0ZUZuLnJhdyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobWVzc2FnZXNPckVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9O1xuICB0cmFuc2xhdGVGbi5oYXMgPSBrZXkgPT4ge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzT3JFcnJvciwga2V5LCBuYW1lc3BhY2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhbnNsYXRlRm47XG59XG5cbi8qKlxuICogRm9yIHRoZSBzdHJpY3RseSB0eXBlZCBtZXNzYWdlcyB0byB3b3JrIHdlIGhhdmUgdG8gd3JhcCB0aGUgbmFtZXNwYWNlIGludG9cbiAqIGEgbWFuZGF0b3J5IHByZWZpeC4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCkge1xuICByZXR1cm4gbmFtZXNwYWNlID09PSBuYW1lc3BhY2VQcmVmaXggPyB1bmRlZmluZWQgOiBuYW1lc3BhY2Uuc2xpY2UoKG5hbWVzcGFjZVByZWZpeCArICcuJykubGVuZ3RoKTtcbn1cblxuY29uc3QgU0VDT05EID0gMTtcbmNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xuY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwO1xuY29uc3QgREFZID0gSE9VUiAqIDI0O1xuY29uc3QgV0VFSyA9IERBWSAqIDc7XG5jb25zdCBNT05USCA9IERBWSAqICgzNjUgLyAxMik7IC8vIEFwcHJveGltYXRpb25cbmNvbnN0IFFVQVJURVIgPSBNT05USCAqIDM7XG5jb25zdCBZRUFSID0gREFZICogMzY1O1xuY29uc3QgVU5JVF9TRUNPTkRTID0ge1xuICBzZWNvbmQ6IFNFQ09ORCxcbiAgc2Vjb25kczogU0VDT05ELFxuICBtaW51dGU6IE1JTlVURSxcbiAgbWludXRlczogTUlOVVRFLFxuICBob3VyOiBIT1VSLFxuICBob3VyczogSE9VUixcbiAgZGF5OiBEQVksXG4gIGRheXM6IERBWSxcbiAgd2VlazogV0VFSyxcbiAgd2Vla3M6IFdFRUssXG4gIG1vbnRoOiBNT05USCxcbiAgbW9udGhzOiBNT05USCxcbiAgcXVhcnRlcjogUVVBUlRFUixcbiAgcXVhcnRlcnM6IFFVQVJURVIsXG4gIHllYXI6IFlFQVIsXG4gIHllYXJzOiBZRUFSXG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykge1xuICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKHNlY29uZHMpO1xuICBpZiAoYWJzVmFsdWUgPCBNSU5VVEUpIHtcbiAgICByZXR1cm4gJ3NlY29uZCc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBIT1VSKSB7XG4gICAgcmV0dXJuICdtaW51dGUnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgREFZKSB7XG4gICAgcmV0dXJuICdob3VyJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFdFRUspIHtcbiAgICByZXR1cm4gJ2RheSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBNT05USCkge1xuICAgIHJldHVybiAnd2Vlayc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBZRUFSKSB7XG4gICAgcmV0dXJuICdtb250aCc7XG4gIH1cbiAgcmV0dXJuICd5ZWFyJztcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpIHtcbiAgLy8gV2UgaGF2ZSB0byByb3VuZCB0aGUgcmVzdWx0aW5nIHZhbHVlcywgYXMgYEludGwuUmVsYXRpdmVUaW1lRm9ybWF0YFxuICAvLyB3aWxsIGluY2x1ZGUgZnJhY3Rpb25zIGxpa2UgJzIuMSBob3VycyBhZ28nLlxuICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzIC8gVU5JVF9TRUNPTkRTW3VuaXRdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgX2NhY2hlOiBjYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgX2Zvcm1hdHRlcnM6IGZvcm1hdHRlcnMgPSBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSksXG4gICAgZm9ybWF0cyxcbiAgICBsb2NhbGUsXG4gICAgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLFxuICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICB9ID0gcHJvcHM7XG4gIGZ1bmN0aW9uIGFwcGx5VGltZVpvbmUob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucz8udGltZVpvbmUpIHtcbiAgICAgIGlmIChnbG9iYWxUaW1lWm9uZSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgYFRoZSBcXGB0aW1lWm9uZVxcYCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL2NvbmZpZ3VyYXRpb24jdGltZS16b25lYCApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGZvcm1hdE9yT3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGZvcm1hdE5hbWUgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gdHlwZUZvcm1hdHM/Lltmb3JtYXROYW1lXTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5NSVNTSU5HX0ZPUk1BVCwgYEZvcm1hdCBcXGAke2Zvcm1hdE5hbWV9XFxgIGlzIG5vdCBhdmFpbGFibGUuYCApO1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgfVxuICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLm92ZXJyaWRlc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIHR5cGVGb3JtYXRzLCBmb3JtYXR0ZXIsIGdldEZhbGxiYWNrKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZSh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/LmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIG9wdGlvbnMgPSBhcHBseVRpbWVab25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpO1xuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/LmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIG9wdGlvbnMgPSBhcHBseVRpbWVab25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9LCAoKSA9PiBbZGF0ZVRpbWUoc3RhcnQpLCBkYXRlVGltZShlbmQpXS5qb2luKCfigInigJPigIknKSk7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8ubnVtYmVyLCBvcHRpb25zID0+IGZvcm1hdHRlcnMuZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsTm93KCkge1xuICAgIC8vIE9ubHkgcmVhZCB3aGVuIG5lY2Vzc2FyeSB0byBhdm9pZCB0cmlnZ2VyaW5nIGEgYGR5bmFtaWNJT2AgZXJyb3JcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IChgbm93YCBpcyBvbmx5IG5lZWRlZCBmb3IgYGZvcm1hdC5yZWxhdGl2ZVRpbWVgKVxuICAgIGlmIChwcm9wcy5ub3cpIHtcbiAgICAgIHJldHVybiBwcm9wcy5ub3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlIFxcYG5vd1xcYCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIHRvIFxcYHJlbGF0aXZlVGltZVxcYCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZCwgdGhlcmVmb3JlIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkIGFzIGEgZmFsbGJhY2suIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9kYXRlcy10aW1lcyNyZWxhdGl2ZS10aW1lcy11c2Vub3dgICkpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShkYXRlLCBub3dPck9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG5vd0RhdGUsIHVuaXQ7XG4gICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICBpZiAobm93T3JPcHRpb25zIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAobm93T3JPcHRpb25zKSB7XG4gICAgICAgIGlmIChub3dPck9wdGlvbnMubm93ICE9IG51bGwpIHtcbiAgICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zLm5vdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHVuaXQgPSBub3dPck9wdGlvbnMudW5pdDtcbiAgICAgICAgb3B0cy5zdHlsZSA9IG5vd09yT3B0aW9ucy5zdHlsZTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBUeXBlcyBhcmUgc2xpZ2h0bHkgb3V0ZGF0ZWRcbiAgICAgICAgb3B0cy5udW1iZXJpbmdTeXN0ZW0gPSBub3dPck9wdGlvbnMubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgfVxuICAgICAgaWYgKCFub3dEYXRlKSB7XG4gICAgICAgIG5vd0RhdGUgPSBnZXRHbG9iYWxOb3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGVEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBjb25zdCBzZWNvbmRzID0gKGRhdGVEYXRlLmdldFRpbWUoKSAtIG5vd0RhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgICBpZiAoIXVuaXQpIHtcbiAgICAgICAgdW5pdCA9IHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBgbnVtZXJpYzogJ2F1dG8nYCBjYW4gdGhlb3JldGljYWxseSBwcm9kdWNlIG91dHB1dCBsaWtlIFwieWVzdGVyZGF5XCIsXG4gICAgICAvLyBidXQgaXQgb25seSB3b3JrcyB3aXRoIGludGVnZXJzLiBFLmcuIC0xIGRheSB3aWxsIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCAtMS4xIGRheXMgd2lsbCBwcm9kdWNlIFwiLTEuMSBkYXlzXCIuIFJvdW5kaW5nIGJlZm9yZSBmb3JtYXR0aW5nIGlzXG4gICAgICAvLyBub3QgZGVzaXJlZCwgYXMgdGhlIGdpdmVuIGRhdGVzIG1pZ2h0IGNyb3NzIGEgdGhyZXNob2xkIHdlcmUgdGhlXG4gICAgICAvLyBvdXRwdXQgaXNuJ3QgY29ycmVjdCBhbnltb3JlLiBFeGFtcGxlOiAyMDI0LTAxLTA4VDIzOjAwOjAwLjAwMFogYW5kXG4gICAgICAvLyAyMDI0LTAxLTA4VDAxOjAwOjAwLjAwMFogd291bGQgcHJvZHVjZSBcInllc3RlcmRheVwiLCB3aGljaCBpcyBub3QgdGhlXG4gICAgICAvLyBjYXNlLiBCeSB1c2luZyBgYWx3YXlzYCB3ZSBjYW4gZW5zdXJlIGNvcnJlY3Qgb3V0cHV0LiBUaGUgb25seSBleGNlcHRpb25cbiAgICAgIC8vIGlzIHRoZSBmb3JtYXR0aW5nIG9mIHRpbWVzIDwxIHNlY29uZCBhcyBcIm5vd1wiLlxuICAgICAgb3B0cy5udW1lcmljID0gdW5pdCA9PT0gJ3NlY29uZCcgPyAnYXV0bycgOiAnYWx3YXlzJztcbiAgICAgIGNvbnN0IHZhbHVlID0gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXRSZWxhdGl2ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRzKS5mb3JtYXQodmFsdWUsIHVuaXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gU3RyaW5nKGRhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsaXN0KHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IFtdO1xuICAgIGNvbnN0IHJpY2hWYWx1ZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBgZm9ybWF0VG9QYXJ0c2Agb25seSBhY2NlcHRzIHN0cmluZ3MsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvIHRlbXBvcmFyaWx5XG4gICAgLy8gcmVwbGFjZSBSZWFjdCBlbGVtZW50cyB3aXRoIGEgcGxhY2Vob2xkZXIgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZVxuICAgIC8vIHRoZSBvcmlnaW5hbCB2YWx1ZSBhZnRlcndhcmRzLlxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICBsZXQgc2VyaWFsaXplZEl0ZW07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gU3RyaW5nKGluZGV4KTtcbiAgICAgICAgcmljaFZhbHVlcy5zZXQoc2VyaWFsaXplZEl0ZW0sIGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaXRlbSk7XG4gICAgICB9XG4gICAgICBzZXJpYWxpemVkVmFsdWUucHVzaChzZXJpYWxpemVkSXRlbSk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/Lmxpc3QsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgcmljaFZhbHVlcy5zaXplYCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGUsIGJ1dCBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHRoZSBtZWFuaW5nIG9mIHRoaXMgY29ycmVjdGx5XG4gICAgb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXR0ZXJzLmdldExpc3RGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRUb1BhcnRzKHNlcmlhbGl6ZWRWYWx1ZSkubWFwKHBhcnQgPT4gcGFydC50eXBlID09PSAnbGl0ZXJhbCcgPyBwYXJ0LnZhbHVlIDogcmljaFZhbHVlcy5nZXQocGFydC52YWx1ZSkgfHwgcGFydC52YWx1ZSk7XG4gICAgICBpZiAocmljaFZhbHVlcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9LCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGVUaW1lLFxuICAgIG51bWJlcixcbiAgICByZWxhdGl2ZVRpbWUsXG4gICAgbGlzdCxcbiAgICBkYXRlVGltZVJhbmdlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBwYXJlbnRQYXRoKSB7XG4gIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2VzKS5mb3JFYWNoKChba2V5LCBtZXNzYWdlT3JNZXNzYWdlc10pID0+IHtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGxldCBrZXlMYWJlbCA9IGtleTtcbiAgICAgIGlmIChwYXJlbnRQYXRoKSBrZXlMYWJlbCArPSBgIChhdCAke3BhcmVudFBhdGh9KWA7XG4gICAgICBpbnZhbGlkS2V5TGFiZWxzLnB1c2goa2V5TGFiZWwpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKG1lc3NhZ2VPck1lc3NhZ2VzICE9IG51bGwgJiYgdHlwZW9mIG1lc3NhZ2VPck1lc3NhZ2VzID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZU9yTWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIGpvaW5QYXRoKHBhcmVudFBhdGgsIGtleSkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBvbkVycm9yKSB7XG4gIGNvbnN0IGludmFsaWRLZXlMYWJlbHMgPSBbXTtcbiAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMpO1xuICBpZiAoaW52YWxpZEtleUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuSU5WQUxJRF9LRVksIGBOYW1lc3BhY2Uga2V5cyBjYW4gbm90IGNvbnRhaW4gdGhlIGNoYXJhY3RlciBcIi5cIiBhcyB0aGlzIGlzIHVzZWQgdG8gZXhwcmVzcyBuZXN0aW5nLiBQbGVhc2UgcmVtb3ZlIGl0IG9yIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyIGNoYXJhY3Rlci5cblxuSW52YWxpZCAke2ludmFsaWRLZXlMYWJlbHMubGVuZ3RoID09PSAxID8gJ2tleScgOiAna2V5cyd9OiAke2ludmFsaWRLZXlMYWJlbHMuam9pbignLCAnKX1cblxuSWYgeW91J3JlIG1pZ3JhdGluZyBmcm9tIGEgZmxhdCBzdHJ1Y3R1cmUsIHlvdSBjYW4gY29udmVydCB5b3VyIG1lc3NhZ2VzIGFzIGZvbGxvd3M6XG5cbmltcG9ydCB7c2V0fSBmcm9tIFwibG9kYXNoXCI7XG5cbmNvbnN0IGlucHV0ID0ge1xuICBcIm9uZS5vbmVcIjogXCIxLjFcIixcbiAgXCJvbmUudHdvXCI6IFwiMS4yXCIsXG4gIFwidHdvLm9uZS5vbmVcIjogXCIyLjEuMVwiXG59O1xuXG5jb25zdCBvdXRwdXQgPSBPYmplY3QuZW50cmllcyhpbnB1dCkucmVkdWNlKFxuICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHNldChhY2MsIGtleSwgdmFsdWUpLFxuICB7fVxuKTtcblxuLy8gT3V0cHV0OlxuLy9cbi8vIHtcbi8vICAgXCJvbmVcIjoge1xuLy8gICAgIFwib25lXCI6IFwiMS4xXCIsXG4vLyAgICAgXCJ0d29cIjogXCIxLjJcIlxuLy8gICB9LFxuLy8gICBcInR3b1wiOiB7XG4vLyAgICAgXCJvbmVcIjoge1xuLy8gICAgICAgXCJvbmVcIjogXCIyLjEuMVwiXG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5gICkpO1xuICB9XG59XG5cbi8qKlxuICogRW5oYW5jZXMgdGhlIGluY29taW5nIHByb3BzIHdpdGggZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDb25maWcoe1xuICBmb3JtYXRzLFxuICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gIG1lc3NhZ2VzLFxuICBvbkVycm9yLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IGZpbmFsT25FcnJvciA9IG9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XG4gIGNvbnN0IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrID0gZ2V0TWVzc2FnZUZhbGxiYWNrIHx8IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2s7XG4gIHtcbiAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIGZpbmFsT25FcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBmb3JtYXRzOiBmb3JtYXRzIHx8IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgdW5kZWZpbmVkLFxuICAgIG9uRXJyb3I6IGZpbmFsT25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrXG4gIH07XG59XG5cbmV4cG9ydCB7IEludGxFcnJvciBhcyBJLCBJbnRsRXJyb3JDb2RlIGFzIGEsIGNyZWF0ZUludGxGb3JtYXR0ZXJzIGFzIGIsIGNyZWF0ZUZvcm1hdHRlciBhcyBjLCBjcmVhdGVDYWNoZSBhcyBkLCBjcmVhdGVCYXNlVHJhbnNsYXRvciBhcyBlLCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIGFzIGYsIGRlZmF1bHRPbkVycm9yIGFzIGcsIGluaXRpYWxpemVDb25maWcgYXMgaSwgcmVzb2x2ZU5hbWVzcGFjZSBhcyByIH07XG4iXSwibmFtZXMiOlsiSW50bE1lc3NhZ2VGb3JtYXQiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsIm1lbW9pemUiLCJzdHJhdGVnaWVzIiwiSW50bEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJvcmlnaW5hbE1lc3NhZ2UiLCJtZXNzYWdlIiwiSW50bEVycm9yQ29kZSIsImNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCIsImdsb2JhbEZvcm1hdHMiLCJpbmxpbmVGb3JtYXRzIiwidGltZVpvbmUiLCJtZkRhdGVEZWZhdWx0cyIsImZvcm1hdHMiLCJkYXRlIiwibWZUaW1lRGVmYXVsdHMiLCJ0aW1lIiwiZGF0ZVRpbWVGb3JtYXRzIiwiZGF0ZVRpbWUiLCJhbGxGb3JtYXRzIiwibnVtYmVyIiwiZm9yRWFjaCIsInByb3BlcnR5Iiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiam9pblBhdGgiLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsInByb3BzIiwibmFtZXNwYWNlIiwiZGVmYXVsdE9uRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJjcmVhdGVDYWNoZSIsInJlbGF0aXZlVGltZSIsInBsdXJhbFJ1bGVzIiwibGlzdCIsImRpc3BsYXlOYW1lcyIsImNyZWF0ZU1lbW9DYWNoZSIsInN0b3JlIiwiY3JlYXRlIiwiZ2V0Iiwic2V0IiwibWVtb0ZuIiwiZm4iLCJjYWNoZSIsInN0cmF0ZWd5IiwidmFyaWFkaWMiLCJtZW1vQ29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvckZuIiwiYXJncyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXROdW1iZXJGb3JtYXQiLCJOdW1iZXJGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwiZ2V0UmVsYXRpdmVUaW1lRm9ybWF0IiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwiZ2V0TGlzdEZvcm1hdCIsIkxpc3RGb3JtYXQiLCJnZXREaXNwbGF5TmFtZXMiLCJEaXNwbGF5TmFtZXMiLCJjcmVhdGVNZXNzYWdlRm9ybWF0dGVyIiwiaW50bEZvcm1hdHRlcnMiLCJnZXRNZXNzYWdlRm9ybWF0IiwiZm9ybWF0dGVycyIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJmdWxsS2V5Iiwic3BsaXQiLCJwYXJ0IiwibmV4dCIsInByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyIsInZhbHVlcyIsInRyYW5zZm9ybWVkVmFsdWVzIiwia2V5cyIsImluZGV4IiwidHJhbnNmb3JtZWQiLCJjaHVua3MiLCJyZXN1bHQiLCJnZXRNZXNzYWdlc09yRXJyb3IiLCJyZXRyaWV2ZWRNZXNzYWdlcyIsImludGxFcnJvciIsIk1JU1NJTkdfTUVTU0FHRSIsImdldFBsYWluTWVzc2FnZSIsImNhbmRpZGF0ZSIsInRlc3QiLCJ1bmRlZmluZWQiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNvbmZpZyIsIm1lc3NhZ2VzT3JFcnJvciIsImNyZWF0ZUJhc2VUcmFuc2xhdG9ySW1wbCIsImdldE1lc3NhZ2VGYWxsYmFjayIsIm9uRXJyb3IiLCJoYXNNZXNzYWdlc0Vycm9yIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJmYWxsYmFjayIsInRyYW5zbGF0ZUJhc2VGbiIsIl9mYWxsYmFjayIsImVycm9yTWVzc2FnZSIsIkFycmF5IiwiaXNBcnJheSIsIklOVkFMSURfTUVTU0FHRSIsIklOU1VGRklDSUVOVF9QQVRIIiwibWVzc2FnZUZvcm1hdCIsInBsYWluTWVzc2FnZSIsImxvY2FsZXMiLCJvcHRpb25zIiwidGhyb3duRXJyb3IiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZm9ybWF0IiwiU3RyaW5nIiwiRk9STUFUVElOR19FUlJPUiIsInRyYW5zbGF0ZUZuIiwicmljaCIsIm1hcmt1cCIsInJhdyIsImhhcyIsInJlc29sdmVOYW1lc3BhY2UiLCJuYW1lc3BhY2VQcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsIlNFQ09ORCIsIk1JTlVURSIsIkhPVVIiLCJEQVkiLCJXRUVLIiwiTU9OVEgiLCJRVUFSVEVSIiwiWUVBUiIsIlVOSVRfU0VDT05EUyIsInNlY29uZCIsInNlY29uZHMiLCJtaW51dGUiLCJtaW51dGVzIiwiaG91ciIsImhvdXJzIiwiZGF5IiwiZGF5cyIsIndlZWsiLCJ3ZWVrcyIsIm1vbnRoIiwibW9udGhzIiwicXVhcnRlciIsInF1YXJ0ZXJzIiwieWVhciIsInllYXJzIiwicmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQiLCJhYnNWYWx1ZSIsIk1hdGgiLCJhYnMiLCJjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZSIsInVuaXQiLCJyb3VuZCIsImNyZWF0ZUZvcm1hdHRlciIsIl9jYWNoZSIsIl9mb3JtYXR0ZXJzIiwiZ2xvYmFsVGltZVpvbmUiLCJhcHBseVRpbWVab25lIiwiRU5WSVJPTk1FTlRfRkFMTEJBQ0siLCJyZXNvbHZlRm9ybWF0T3JPcHRpb25zIiwidHlwZUZvcm1hdHMiLCJmb3JtYXRPck9wdGlvbnMiLCJvdmVycmlkZXMiLCJmb3JtYXROYW1lIiwiTUlTU0lOR19GT1JNQVQiLCJnZXRGb3JtYXR0ZWRWYWx1ZSIsImZvcm1hdHRlciIsImdldEZhbGxiYWNrIiwiZGF0ZVRpbWVSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZm9ybWF0UmFuZ2UiLCJnZXRHbG9iYWxOb3ciLCJub3ciLCJEYXRlIiwibm93T3JPcHRpb25zIiwibm93RGF0ZSIsIm9wdHMiLCJzdHlsZSIsIm51bWJlcmluZ1N5c3RlbSIsImRhdGVEYXRlIiwiZ2V0VGltZSIsIm51bWVyaWMiLCJzZXJpYWxpemVkVmFsdWUiLCJyaWNoVmFsdWVzIiwiTWFwIiwiaXRlbSIsInNlcmlhbGl6ZWRJdGVtIiwicHVzaCIsImZvcm1hdFRvUGFydHMiLCJtYXAiLCJ0eXBlIiwic2l6ZSIsInZhbGlkYXRlTWVzc2FnZXNTZWdtZW50IiwiaW52YWxpZEtleUxhYmVscyIsInBhcmVudFBhdGgiLCJtZXNzYWdlT3JNZXNzYWdlcyIsImluY2x1ZGVzIiwia2V5TGFiZWwiLCJ2YWxpZGF0ZU1lc3NhZ2VzIiwiSU5WQUxJRF9LRVkiLCJpbml0aWFsaXplQ29uZmlnIiwicmVzdCIsImZpbmFsT25FcnJvciIsImZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrIiwiSSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJpIiwiciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/react.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/react.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntlProvider: () => (/* binding */ IntlProvider),\n/* harmony export */   _useExtracted: () => (/* binding */ useExtracted),\n/* harmony export */   useFormatter: () => (/* binding */ useFormatter),\n/* harmony export */   useLocale: () => (/* binding */ useLocale),\n/* harmony export */   useMessages: () => (/* binding */ useMessages),\n/* harmony export */   useNow: () => (/* binding */ useNow),\n/* harmony export */   useTimeZone: () => (/* binding */ useTimeZone),\n/* harmony export */   useTranslations: () => (/* binding */ useTranslations)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initializeConfig-CIDVMS2E.js */ \"(ssr)/../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n\n\n\nconst IntlContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nfunction IntlProvider({ children, formats, getMessageFallback, locale, messages, now, onError, timeZone }) {\n    const prevContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n    // The formatter cache is released when the locale changes. For\n    // long-running apps with a persistent `IntlProvider` at the root,\n    // this can reduce the memory footprint (e.g. in React Native).\n    const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return prevContext?.cache || (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.d)();\n    }, [\n        locale,\n        prevContext?.cache\n    ]);\n    const formatters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>prevContext?.formatters || (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.b)(cache), [\n        cache,\n        prevContext?.formatters\n    ]);\n    // Memoizing this value helps to avoid triggering a re-render of all\n    // context consumers in case the configuration didn't change. However,\n    // if some of the non-primitive values change, a re-render will still\n    // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n    // itself, because the `children` typically change on every render.\n    // There's some burden on the consumer side if it's important to reduce\n    // re-renders, put that's how React works.\n    // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.i)({\n                locale,\n                // (required by provider)\n                formats: formats === undefined ? prevContext?.formats : formats,\n                getMessageFallback: getMessageFallback || prevContext?.getMessageFallback,\n                messages: messages === undefined ? prevContext?.messages : messages,\n                now: now || prevContext?.now,\n                onError: onError || prevContext?.onError,\n                timeZone: timeZone || prevContext?.timeZone\n            }),\n            formatters,\n            cache\n        }), [\n        cache,\n        formats,\n        formatters,\n        getMessageFallback,\n        locale,\n        messages,\n        now,\n        onError,\n        prevContext,\n        timeZone\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IntlContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useIntlContext() {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n    if (!context) {\n        throw new Error(\"No intl context found. Have you configured the provider? See https://next-intl.dev/docs/usage/configuration#server-client-components\");\n    }\n    return context;\n}\nlet hasWarnedForMissingTimezone = false;\nconst isServer = \"undefined\" === \"undefined\";\nfunction useTranslationsImpl(allMessagesPrefixed, namespacePrefixed, namespacePrefix) {\n    const { cache, formats: globalFormats, formatters, getMessageFallback, locale, onError, timeZone } = useIntlContext();\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the hook invocation.\n    const allMessages = allMessagesPrefixed[namespacePrefix];\n    const namespace = (0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.r)(namespacePrefixed, namespacePrefix);\n    if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n        // eslint-disable-next-line react-compiler/react-compiler\n        hasWarnedForMissingTimezone = true;\n        onError(new _initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.I(_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.a.ENVIRONMENT_FALLBACK, `There is no \\`timeZone\\` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl.dev/docs/configuration#time-zone`));\n    }\n    const translate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.e)({\n            cache,\n            formatters,\n            getMessageFallback,\n            messages: allMessages,\n            namespace,\n            onError,\n            formats: globalFormats,\n            locale,\n            timeZone\n        }), [\n        cache,\n        formatters,\n        getMessageFallback,\n        allMessages,\n        namespace,\n        onError,\n        globalFormats,\n        locale,\n        timeZone\n    ]);\n    return translate;\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function useTranslations(namespace) {\n    const context = useIntlContext();\n    const messages = context.messages;\n    // We have to wrap the actual hook so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    // @ts-expect-error Use the explicit annotation instead\n    return useTranslationsImpl({\n        \"!\": messages\n    }, // @ts-expect-error\n    namespace ? `!.${namespace}` : \"!\", \"!\");\n}\nfunction useLocale() {\n    return useIntlContext().locale;\n}\nfunction getNow() {\n    return new Date();\n}\n/**\n * @see https://next-intl.dev/docs/usage/dates-times#relative-times-usenow\n */ function useNow(options) {\n    const updateInterval = options?.updateInterval;\n    const { now: globalNow } = useIntlContext();\n    const [now, setNow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalNow || getNow());\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!updateInterval) return;\n        const intervalId = setInterval(()=>{\n            setNow(getNow());\n        }, updateInterval);\n        return ()=>{\n            clearInterval(intervalId);\n        };\n    }, [\n        globalNow,\n        updateInterval\n    ]);\n    return updateInterval == null && globalNow ? globalNow : now;\n}\nfunction useTimeZone() {\n    return useIntlContext().timeZone;\n}\nfunction useMessages() {\n    const context = useIntlContext();\n    if (!context.messages) {\n        throw new Error(\"No messages found. Have you configured them correctly? See https://next-intl.dev/docs/configuration#messages\");\n    }\n    return context.messages;\n}\nfunction useFormatter() {\n    const { formats, formatters, locale, now: globalNow, onError, timeZone } = useIntlContext();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_initializeConfig_CIDVMS2E_js__WEBPACK_IMPORTED_MODULE_2__.c)({\n            formats,\n            locale,\n            now: globalNow,\n            onError,\n            timeZone,\n            _formatters: formatters\n        }), [\n        formats,\n        formatters,\n        globalNow,\n        locale,\n        onError,\n        timeZone\n    ]);\n}\nfunction getArgs(messageOrParams, ...rest) {\n    let message, values, formats;\n    if (typeof messageOrParams === \"string\") {\n        message = messageOrParams;\n        values = rest[0];\n        formats = rest[1];\n    } else {\n        message = messageOrParams.message;\n        values = messageOrParams.values;\n        formats = messageOrParams.formats;\n    // `description` is is not used at runtime\n    }\n    // @ts-expect-error -- Secret fallback parameter\n    return [\n        undefined,\n        // Always use fallback if not compiled\n        values,\n        formats,\n        message\n    ];\n}\n// Note: This API is usually compiled into `useTranslations`,\n// but there is some fallback handling which allows this hook\n// to still work when not being compiled.\n//\n// This is relevant for:\n// - Isolated environments like tests, Storybook, etc.\n// - Fallbacks in case an extracted message is not yet available\nfunction useExtracted(namespace) {\n    const t = useTranslations(namespace);\n    function translateFn(...params) {\n        // @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        return t(...getArgs(...params));\n    }\n    translateFn.rich = (...params)=>// @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        t.rich(...getArgs(...params));\n    translateFn.markup = (...params)=>// @ts-expect-error -- Passing `undefined` as an ID is secretly allowed here\n        t.markup(...getArgs(...params));\n    translateFn.has = function translateHasFn(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    message) {\n        // Not really something better we can do here\n        return true;\n    };\n    return translateFn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VzZS1pbnRsQDQuNS44X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Y7QUFDZ0o7QUFDeEw7QUFJeEMsTUFBTXNCLGNBQWMsV0FBVyxHQUFFdEIsb0RBQWFBLENBQUN1QjtBQUUvQyxTQUFTQyxhQUFhLEVBQ3BCQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEMsa0JBQWtCLEVBQ2xCQyxNQUFNLEVBQ05DLFFBQVEsRUFDUkMsR0FBRyxFQUNIQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVDtJQUNDLE1BQU1DLGNBQWNoQyxpREFBVUEsQ0FBQ3FCO0lBRS9CLCtEQUErRDtJQUMvRCxrRUFBa0U7SUFDbEUsK0RBQStEO0lBQy9ELE1BQU1ZLFFBQVFoQyw4Q0FBT0EsQ0FBQztRQUNwQixPQUFPK0IsYUFBYUMsU0FBUzVCLGdFQUFXQTtJQUMxQyxHQUFHO1FBQUNzQjtRQUFRSyxhQUFhQztLQUFNO0lBQy9CLE1BQU1DLGFBQWFqQyw4Q0FBT0EsQ0FBQyxJQUFNK0IsYUFBYUUsY0FBYzNCLGdFQUFvQkEsQ0FBQzBCLFFBQVE7UUFBQ0E7UUFBT0QsYUFBYUU7S0FBVztJQUV6SCxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLHFFQUFxRTtJQUNyRSwwRUFBMEU7SUFDMUUsbUVBQW1FO0lBQ25FLHVFQUF1RTtJQUN2RSwwQ0FBMEM7SUFDMUMsK0pBQStKO0lBQy9KLE1BQU1DLFFBQVFsQyw4Q0FBT0EsQ0FBQyxJQUFPO1lBQzNCLEdBQUdRLGdFQUFnQkEsQ0FBQztnQkFDbEJrQjtnQkFDQSx5QkFBeUI7Z0JBQ3pCRixTQUFTQSxZQUFZSCxZQUFZVSxhQUFhUCxVQUFVQTtnQkFDeERDLG9CQUFvQkEsc0JBQXNCTSxhQUFhTjtnQkFDdkRFLFVBQVVBLGFBQWFOLFlBQVlVLGFBQWFKLFdBQVdBO2dCQUMzREMs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QUcsQ0FBQyxHQUFHRCxTQUN2Qiw0RUFBNEU7UUFDNUVGLEVBQUVHLElBQUksSUFBSVQsV0FBV1E7SUFDckJELFlBQVlHLE1BQU0sR0FBRyxDQUFDLEdBQUdGLFNBQ3pCLDRFQUE0RTtRQUM1RUYsRUFBRUksTUFBTSxJQUFJVixXQUFXUTtJQUN2QkQsWUFBWUksR0FBRyxHQUFHLFNBQVNDLGVBQzNCLDZEQUE2RDtJQUM3RFQsT0FBTztRQUNMLDZDQUE2QztRQUM3QyxPQUFPO0lBQ1Q7SUFDQSxPQUFPSTtBQUNUO0FBRW1JIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91c2UtaW50bEA0LjUuOF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L3JlYWN0LmpzPzc0MmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGQgYXMgY3JlYXRlQ2FjaGUsIGIgYXMgY3JlYXRlSW50bEZvcm1hdHRlcnMsIGkgYXMgaW5pdGlhbGl6ZUNvbmZpZywgciBhcyByZXNvbHZlTmFtZXNwYWNlLCBJIGFzIEludGxFcnJvciwgYSBhcyBJbnRsRXJyb3JDb2RlLCBlIGFzIGNyZWF0ZUJhc2VUcmFuc2xhdG9yLCBjIGFzIGNyZWF0ZUZvcm1hdHRlciB9IGZyb20gJy4vaW5pdGlhbGl6ZUNvbmZpZy1DSURWTVMyRS5qcyc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5cblxuXG5jb25zdCBJbnRsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIEludGxQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBmb3JtYXRzLFxuICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gIGxvY2FsZSxcbiAgbWVzc2FnZXMsXG4gIG5vdyxcbiAgb25FcnJvcixcbiAgdGltZVpvbmVcbn0pIHtcbiAgY29uc3QgcHJldkNvbnRleHQgPSB1c2VDb250ZXh0KEludGxDb250ZXh0KTtcblxuICAvLyBUaGUgZm9ybWF0dGVyIGNhY2hlIGlzIHJlbGVhc2VkIHdoZW4gdGhlIGxvY2FsZSBjaGFuZ2VzLiBGb3JcbiAgLy8gbG9uZy1ydW5uaW5nIGFwcHMgd2l0aCBhIHBlcnNpc3RlbnQgYEludGxQcm92aWRlcmAgYXQgdGhlIHJvb3QsXG4gIC8vIHRoaXMgY2FuIHJlZHVjZSB0aGUgbWVtb3J5IGZvb3RwcmludCAoZS5nLiBpbiBSZWFjdCBOYXRpdmUpLlxuICBjb25zdCBjYWNoZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBwcmV2Q29udGV4dD8uY2FjaGUgfHwgY3JlYXRlQ2FjaGUoKTtcbiAgfSwgW2xvY2FsZSwgcHJldkNvbnRleHQ/LmNhY2hlXSk7XG4gIGNvbnN0IGZvcm1hdHRlcnMgPSB1c2VNZW1vKCgpID0+IHByZXZDb250ZXh0Py5mb3JtYXR0ZXJzIHx8IGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSwgW2NhY2hlLCBwcmV2Q29udGV4dD8uZm9ybWF0dGVyc10pO1xuXG4gIC8vIE1lbW9pemluZyB0aGlzIHZhbHVlIGhlbHBzIHRvIGF2b2lkIHRyaWdnZXJpbmcgYSByZS1yZW5kZXIgb2YgYWxsXG4gIC8vIGNvbnRleHQgY29uc3VtZXJzIGluIGNhc2UgdGhlIGNvbmZpZ3VyYXRpb24gZGlkbid0IGNoYW5nZS4gSG93ZXZlcixcbiAgLy8gaWYgc29tZSBvZiB0aGUgbm9uLXByaW1pdGl2ZSB2YWx1ZXMgY2hhbmdlLCBhIHJlLXJlbmRlciB3aWxsIHN0aWxsXG4gIC8vIGJlIHRyaWdnZXJlZC4gTm90ZSB0aGF0IHRoZXJlJ3Mgbm8gbmVlZCB0byBwdXQgYG1lbW9gIG9uIGBJbnRsUHJvdmlkZXJgXG4gIC8vIGl0c2VsZiwgYmVjYXVzZSB0aGUgYGNoaWxkcmVuYCB0eXBpY2FsbHkgY2hhbmdlIG9uIGV2ZXJ5IHJlbmRlci5cbiAgLy8gVGhlcmUncyBzb21lIGJ1cmRlbiBvbiB0aGUgY29uc3VtZXIgc2lkZSBpZiBpdCdzIGltcG9ydGFudCB0byByZWR1Y2VcbiAgLy8gcmUtcmVuZGVycywgcHV0IHRoYXQncyBob3cgUmVhY3Qgd29ya3MuXG4gIC8vIFNlZTogaHR0cHM6Ly9ibG9nLmlzcXVhcmVkc29mdHdhcmUuY29tLzIwMjAvMDUvYmxvZ2dlZC1hbnN3ZXJzLWEtbW9zdGx5LWNvbXBsZXRlLWd1aWRlLXRvLXJlYWN0LXJlbmRlcmluZy1iZWhhdmlvci8jY29udGV4dC11cGRhdGVzLWFuZC1yZW5kZXItb3B0aW1pemF0aW9uc1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5pbml0aWFsaXplQ29uZmlnKHtcbiAgICAgIGxvY2FsZSxcbiAgICAgIC8vIChyZXF1aXJlZCBieSBwcm92aWRlcilcbiAgICAgIGZvcm1hdHM6IGZvcm1hdHMgPT09IHVuZGVmaW5lZCA/IHByZXZDb250ZXh0Py5mb3JtYXRzIDogZm9ybWF0cyxcbiAgICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZ2V0TWVzc2FnZUZhbGxiYWNrIHx8IHByZXZDb250ZXh0Py5nZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgICBtZXNzYWdlczogbWVzc2FnZXMgPT09IHVuZGVmaW5lZCA/IHByZXZDb250ZXh0Py5tZXNzYWdlcyA6IG1lc3NhZ2VzLFxuICAgICAgbm93OiBub3cgfHwgcHJldkNvbnRleHQ/Lm5vdyxcbiAgICAgIG9uRXJyb3I6IG9uRXJyb3IgfHwgcHJldkNvbnRleHQ/Lm9uRXJyb3IsXG4gICAgICB0aW1lWm9uZTogdGltZVpvbmUgfHwgcHJldkNvbnRleHQ/LnRpbWVab25lXG4gICAgfSksXG4gICAgZm9ybWF0dGVycyxcbiAgICBjYWNoZVxuICB9KSwgW2NhY2hlLCBmb3JtYXRzLCBmb3JtYXR0ZXJzLCBnZXRNZXNzYWdlRmFsbGJhY2ssIGxvY2FsZSwgbWVzc2FnZXMsIG5vdywgb25FcnJvciwgcHJldkNvbnRleHQsIHRpbWVab25lXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEludGxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlSW50bENvbnRleHQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEludGxDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnRsIGNvbnRleHQgZm91bmQuIEhhdmUgeW91IGNvbmZpZ3VyZWQgdGhlIHByb3ZpZGVyPyBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvY29uZmlndXJhdGlvbiNzZXJ2ZXItY2xpZW50LWNvbXBvbmVudHMnICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmxldCBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSBmYWxzZTtcbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiB1c2VUcmFuc2xhdGlvbnNJbXBsKGFsbE1lc3NhZ2VzUHJlZml4ZWQsIG5hbWVzcGFjZVByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgY29uc3Qge1xuICAgIGNhY2hlLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbG9jYWxlLFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSA9IHVzZUludGxDb250ZXh0KCk7XG5cbiAgLy8gVGhlIGBuYW1lc3BhY2VQcmVmaXhgIGlzIHBhcnQgb2YgdGhlIHR5cGUgc3lzdGVtLlxuICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gdGhlIGhvb2sgaW52b2NhdGlvbi5cbiAgY29uc3QgYWxsTWVzc2FnZXMgPSBhbGxNZXNzYWdlc1ByZWZpeGVkW25hbWVzcGFjZVByZWZpeF07XG4gIGNvbnN0IG5hbWVzcGFjZSA9IHJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlUHJlZml4ZWQsIG5hbWVzcGFjZVByZWZpeCk7XG4gIGlmICghdGltZVpvbmUgJiYgIWhhc1dhcm5lZEZvck1pc3NpbmdUaW1lem9uZSAmJiBpc1NlcnZlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1jb21waWxlci9yZWFjdC1jb21waWxlclxuICAgIGhhc1dhcm5lZEZvck1pc3NpbmdUaW1lem9uZSA9IHRydWU7XG4gICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGVyZSBpcyBubyBcXGB0aW1lWm9uZVxcYCBjb25maWd1cmVkLCB0aGlzIGNhbiBsZWFkIHRvIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQ6IGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL2NvbmZpZ3VyYXRpb24jdGltZS16b25lYCApKTtcbiAgfVxuICBjb25zdCB0cmFuc2xhdGUgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZUJhc2VUcmFuc2xhdG9yKHtcbiAgICBjYWNoZSxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlczogYWxsTWVzc2FnZXMsXG4gICAgbmFtZXNwYWNlLFxuICAgIG9uRXJyb3IsXG4gICAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgICBsb2NhbGUsXG4gICAgdGltZVpvbmVcbiAgfSksIFtjYWNoZSwgZm9ybWF0dGVycywgZ2V0TWVzc2FnZUZhbGxiYWNrLCBhbGxNZXNzYWdlcywgbmFtZXNwYWNlLCBvbkVycm9yLCBnbG9iYWxGb3JtYXRzLCBsb2NhbGUsIHRpbWVab25lXSk7XG4gIHJldHVybiB0cmFuc2xhdGU7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyBtZXNzYWdlcyBmcm9tIHRoZSBnaXZlbiBuYW1lc3BhY2UgYnkgdXNpbmcgdGhlIElDVSBzeW50YXguXG4gKiBTZWUgaHR0cHM6Ly9mb3JtYXRqcy5pby9kb2NzL2NvcmUtY29uY2VwdHMvaWN1LXN5bnRheC5cbiAqXG4gKiBJZiBubyBuYW1lc3BhY2UgaXMgcHJvdmlkZWQsIGFsbCBhdmFpbGFibGUgbWVzc2FnZXMgYXJlIHJldHVybmVkLlxuICogVGhlIG5hbWVzcGFjZSBjYW4gYWxzbyBpbmRpY2F0ZSBuZXN0aW5nIGJ5IHVzaW5nIGEgZG90XG4gKiAoZS5nLiBgbmFtZXNwYWNlLkNvbXBvbmVudGApLlxuICovXG5mdW5jdGlvbiB1c2VUcmFuc2xhdGlvbnMobmFtZXNwYWNlKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VJbnRsQ29udGV4dCgpO1xuICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQubWVzc2FnZXM7XG5cbiAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBhY3R1YWwgaG9vayBzbyB0aGUgdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBvcHRpb25hbFxuICAvLyBuYW1lc3BhY2Ugd29ya3MgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICAvLyBUaGUgcHJlZml4IChcIiFcIikgaXMgYXJiaXRyYXJ5LlxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFVzZSB0aGUgZXhwbGljaXQgYW5ub3RhdGlvbiBpbnN0ZWFkXG4gIHJldHVybiB1c2VUcmFuc2xhdGlvbnNJbXBsKHtcbiAgICAnISc6IG1lc3NhZ2VzXG4gIH0sXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbmFtZXNwYWNlID8gYCEuJHtuYW1lc3BhY2V9YCA6ICchJywgJyEnKTtcbn1cblxuZnVuY3Rpb24gdXNlTG9jYWxlKCkge1xuICByZXR1cm4gdXNlSW50bENvbnRleHQoKS5sb2NhbGU7XG59XG5cbmZ1bmN0aW9uIGdldE5vdygpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCk7XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9kYXRlcy10aW1lcyNyZWxhdGl2ZS10aW1lcy11c2Vub3dcbiAqL1xuZnVuY3Rpb24gdXNlTm93KG9wdGlvbnMpIHtcbiAgY29uc3QgdXBkYXRlSW50ZXJ2YWwgPSBvcHRpb25zPy51cGRhdGVJbnRlcnZhbDtcbiAgY29uc3Qge1xuICAgIG5vdzogZ2xvYmFsTm93XG4gIH0gPSB1c2VJbnRsQ29udGV4dCgpO1xuICBjb25zdCBbbm93LCBzZXROb3ddID0gdXNlU3RhdGUoZ2xvYmFsTm93IHx8IGdldE5vdygpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXVwZGF0ZUludGVydmFsKSByZXR1cm47XG4gICAgY29uc3QgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNldE5vdyhnZXROb3coKSk7XG4gICAgfSwgdXBkYXRlSW50ZXJ2YWwpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH07XG4gIH0sIFtnbG9iYWxOb3csIHVwZGF0ZUludGVydmFsXSk7XG4gIHJldHVybiB1cGRhdGVJbnRlcnZhbCA9PSBudWxsICYmIGdsb2JhbE5vdyA/IGdsb2JhbE5vdyA6IG5vdztcbn1cblxuZnVuY3Rpb24gdXNlVGltZVpvbmUoKSB7XG4gIHJldHVybiB1c2VJbnRsQ29udGV4dCgpLnRpbWVab25lO1xufVxuXG5mdW5jdGlvbiB1c2VNZXNzYWdlcygpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUludGxDb250ZXh0KCk7XG4gIGlmICghY29udGV4dC5tZXNzYWdlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbWVzc2FnZXMgZm91bmQuIEhhdmUgeW91IGNvbmZpZ3VyZWQgdGhlbSBjb3JyZWN0bHk/IFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI21lc3NhZ2VzJyApO1xuICB9XG4gIHJldHVybiBjb250ZXh0Lm1lc3NhZ2VzO1xufVxuXG5mdW5jdGlvbiB1c2VGb3JtYXR0ZXIoKSB7XG4gIGNvbnN0IHtcbiAgICBmb3JtYXRzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSA9IHVzZUludGxDb250ZXh0KCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgZm9ybWF0cyxcbiAgICBsb2NhbGUsXG4gICAgbm93OiBnbG9iYWxOb3csXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZSxcbiAgICBfZm9ybWF0dGVyczogZm9ybWF0dGVyc1xuICB9KSwgW2Zvcm1hdHMsIGZvcm1hdHRlcnMsIGdsb2JhbE5vdywgbG9jYWxlLCBvbkVycm9yLCB0aW1lWm9uZV0pO1xufVxuXG5mdW5jdGlvbiBnZXRBcmdzKG1lc3NhZ2VPclBhcmFtcywgLi4ucmVzdCkge1xuICBsZXQgbWVzc2FnZSwgdmFsdWVzLCBmb3JtYXRzO1xuICBpZiAodHlwZW9mIG1lc3NhZ2VPclBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZU9yUGFyYW1zO1xuICAgIHZhbHVlcyA9IHJlc3RbMF07XG4gICAgZm9ybWF0cyA9IHJlc3RbMV07XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2VPclBhcmFtcy5tZXNzYWdlO1xuICAgIHZhbHVlcyA9IG1lc3NhZ2VPclBhcmFtcy52YWx1ZXM7XG4gICAgZm9ybWF0cyA9IG1lc3NhZ2VPclBhcmFtcy5mb3JtYXRzO1xuICAgIC8vIGBkZXNjcmlwdGlvbmAgaXMgaXMgbm90IHVzZWQgYXQgcnVudGltZVxuICB9XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gU2VjcmV0IGZhbGxiYWNrIHBhcmFtZXRlclxuICByZXR1cm4gW3VuZGVmaW5lZCxcbiAgLy8gQWx3YXlzIHVzZSBmYWxsYmFjayBpZiBub3QgY29tcGlsZWRcbiAgdmFsdWVzLCBmb3JtYXRzLCBtZXNzYWdlIF07XG59XG5cbi8vIE5vdGU6IFRoaXMgQVBJIGlzIHVzdWFsbHkgY29tcGlsZWQgaW50byBgdXNlVHJhbnNsYXRpb25zYCxcbi8vIGJ1dCB0aGVyZSBpcyBzb21lIGZhbGxiYWNrIGhhbmRsaW5nIHdoaWNoIGFsbG93cyB0aGlzIGhvb2tcbi8vIHRvIHN0aWxsIHdvcmsgd2hlbiBub3QgYmVpbmcgY29tcGlsZWQuXG4vL1xuLy8gVGhpcyBpcyByZWxldmFudCBmb3I6XG4vLyAtIElzb2xhdGVkIGVudmlyb25tZW50cyBsaWtlIHRlc3RzLCBTdG9yeWJvb2ssIGV0Yy5cbi8vIC0gRmFsbGJhY2tzIGluIGNhc2UgYW4gZXh0cmFjdGVkIG1lc3NhZ2UgaXMgbm90IHlldCBhdmFpbGFibGVcbmZ1bmN0aW9uIHVzZUV4dHJhY3RlZChuYW1lc3BhY2UpIHtcbiAgY29uc3QgdCA9IHVzZVRyYW5zbGF0aW9ucyhuYW1lc3BhY2UpO1xuICBmdW5jdGlvbiB0cmFuc2xhdGVGbiguLi5wYXJhbXMpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFBhc3NpbmcgYHVuZGVmaW5lZGAgYXMgYW4gSUQgaXMgc2VjcmV0bHkgYWxsb3dlZCBoZXJlXG4gICAgcmV0dXJuIHQoLi4uZ2V0QXJncyguLi5wYXJhbXMpKTtcbiAgfVxuICB0cmFuc2xhdGVGbi5yaWNoID0gKC4uLnBhcmFtcykgPT5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBQYXNzaW5nIGB1bmRlZmluZWRgIGFzIGFuIElEIGlzIHNlY3JldGx5IGFsbG93ZWQgaGVyZVxuICB0LnJpY2goLi4uZ2V0QXJncyguLi5wYXJhbXMpKTtcbiAgdHJhbnNsYXRlRm4ubWFya3VwID0gKC4uLnBhcmFtcykgPT5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBQYXNzaW5nIGB1bmRlZmluZWRgIGFzIGFuIElEIGlzIHNlY3JldGx5IGFsbG93ZWQgaGVyZVxuICB0Lm1hcmt1cCguLi5nZXRBcmdzKC4uLnBhcmFtcykpO1xuICB0cmFuc2xhdGVGbi5oYXMgPSBmdW5jdGlvbiB0cmFuc2xhdGVIYXNGbihcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBtZXNzYWdlKSB7XG4gICAgLy8gTm90IHJlYWxseSBzb21ldGhpbmcgYmV0dGVyIHdlIGNhbiBkbyBoZXJlXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuZXhwb3J0IHsgSW50bFByb3ZpZGVyLCB1c2VFeHRyYWN0ZWQgYXMgX3VzZUV4dHJhY3RlZCwgdXNlRm9ybWF0dGVyLCB1c2VMb2NhbGUsIHVzZU1lc3NhZ2VzLCB1c2VOb3csIHVzZVRpbWVab25lLCB1c2VUcmFuc2xhdGlvbnMgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImQiLCJjcmVhdGVDYWNoZSIsImIiLCJjcmVhdGVJbnRsRm9ybWF0dGVycyIsImkiLCJpbml0aWFsaXplQ29uZmlnIiwiciIsInJlc29sdmVOYW1lc3BhY2UiLCJJIiwiSW50bEVycm9yIiwiYSIsIkludGxFcnJvckNvZGUiLCJlIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjIiwiY3JlYXRlRm9ybWF0dGVyIiwianN4IiwiSW50bENvbnRleHQiLCJ1bmRlZmluZWQiLCJJbnRsUHJvdmlkZXIiLCJjaGlsZHJlbiIsImZvcm1hdHMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJsb2NhbGUiLCJtZXNzYWdlcyIsIm5vdyIsIm9uRXJyb3IiLCJ0aW1lWm9uZSIsInByZXZDb250ZXh0IiwiY2FjaGUiLCJmb3JtYXR0ZXJzIiwidmFsdWUiLCJQcm92aWRlciIsInVzZUludGxDb250ZXh0IiwiY29udGV4dCIsIkVycm9yIiwiaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lIiwiaXNTZXJ2ZXIiLCJ1c2VUcmFuc2xhdGlvbnNJbXBsIiwiYWxsTWVzc2FnZXNQcmVmaXhlZCIsIm5hbWVzcGFjZVByZWZpeGVkIiwibmFtZXNwYWNlUHJlZml4IiwiZ2xvYmFsRm9ybWF0cyIsImFsbE1lc3NhZ2VzIiwibmFtZXNwYWNlIiwiRU5WSVJPTk1FTlRfRkFMTEJBQ0siLCJ0cmFuc2xhdGUiLCJ1c2VUcmFuc2xhdGlvbnMiLCJ1c2VMb2NhbGUiLCJnZXROb3ciLCJEYXRlIiwidXNlTm93Iiwib3B0aW9ucyIsInVwZGF0ZUludGVydmFsIiwiZ2xvYmFsTm93Iiwic2V0Tm93IiwiaW50ZXJ2YWxJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInVzZVRpbWVab25lIiwidXNlTWVzc2FnZXMiLCJ1c2VGb3JtYXR0ZXIiLCJfZm9ybWF0dGVycyIsImdldEFyZ3MiLCJtZXNzYWdlT3JQYXJhbXMiLCJyZXN0IiwibWVzc2FnZSIsInZhbHVlcyIsInVzZUV4dHJhY3RlZCIsInQiLCJ0cmFuc2xhdGVGbiIsInBhcmFtcyIsInJpY2giLCJtYXJrdXAiLCJoYXMiLCJ0cmFuc2xhdGVIYXNGbiIsIl91c2VFeHRyYWN0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/react.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(rsc)/../../node_modules/.pnpm/intl-messageformat@10.7.18/node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(rsc)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(rsc)/../../node_modules/.pnpm/@formatjs+fast-memoize@2.2.7/node_modules/@formatjs/fast-memoize/lib/index.js\");\n\n\n\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nvar IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}(IntlErrorCode || {});\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n    const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n    const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n    const dateTimeFormats = {\n        ...globalFormats?.dateTime,\n        ...inlineFormats?.dateTime\n    };\n    const allFormats = {\n        date: {\n            ...mfDateDefaults,\n            ...dateTimeFormats\n        },\n        time: {\n            ...mfTimeDefaults,\n            ...dateTimeFormats\n        },\n        number: {\n            ...globalFormats?.number,\n            ...inlineFormats?.number\n        }\n    };\n    if (timeZone) {\n        // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n        // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n        [\n            \"date\",\n            \"time\"\n        ].forEach((property)=>{\n            const formats = allFormats[property];\n            for (const [key, value] of Object.entries(formats)){\n                formats[key] = {\n                    timeZone,\n                    ...value\n                };\n            }\n        });\n    }\n    return allFormats;\n}\nfunction joinPath(...parts) {\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction createCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {}\n    };\n}\nfunction createMemoCache(store) {\n    return {\n        create () {\n            return {\n                get (key) {\n                    return store[key];\n                },\n                set (key, value) {\n                    store[key] = value;\n                }\n            };\n        }\n    };\n}\nfunction memoFn(fn, cache) {\n    return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n        cache: createMemoCache(cache),\n        strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n    });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n    return memoFn((...args)=>new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n    const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n    const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n    const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n    const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n    const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n    const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n    return {\n        getDateTimeFormat,\n        getNumberFormat,\n        getPluralRules,\n        getRelativeTimeFormat,\n        getListFormat,\n        getDisplayNames\n    };\n}\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n    const getMessageFormat = memoFn((...args)=>new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], {\n            formatters: intlFormatters,\n            ...args[3]\n        }), cache.message);\n    return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(`No messages available at \\`${namespace}\\`.`);\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (part == null || next == null) {\n            throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    try {\n        if (!messages) {\n            throw new Error(`No messages were configured.`);\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!retrievedMessages) {\n            throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    // To improve runtime performance, only compile message if:\n    return(// 1. Values are provided\n    values || // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) || // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n     : candidate // Don't compile\n    );\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl({ cache, formats: globalFormats, formatters, getMessageFallback = defaultGetMessageFallback, locale, messagesOrError, namespace, onError, timeZone }) {\n    const hasMessagesError = messagesOrError instanceof IntlError;\n    function getFallbackFromErrorAndNotify(key, code, message, fallback) {\n        const error = new IntlError(code, message);\n        onError(error);\n        return fallback ?? getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats, _fallback) {\n        const fallback = _fallback;\n        let message;\n        if (hasMessagesError) {\n            if (fallback) {\n                message = fallback;\n            } else {\n                onError(messagesOrError);\n                return getMessageFallback({\n                    error: messagesOrError,\n                    key,\n                    namespace\n                });\n            }\n        } else {\n            const messages = messagesOrError;\n            try {\n                message = resolvePath(locale, messages, key, namespace);\n            } catch (error) {\n                if (fallback) {\n                    message = fallback;\n                } else {\n                    return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message, fallback);\n                }\n            }\n        }\n        if (typeof message === \"object\") {\n            let code, errorMessage;\n            if (Array.isArray(message)) {\n                code = IntlErrorCode.INVALID_MESSAGE;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/translations#arrays-of-messages`;\n                }\n            } else {\n                code = IntlErrorCode.INSUFFICIENT_PATH;\n                {\n                    errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/translations#structuring-messages`;\n                }\n            }\n            return getFallbackFromErrorAndNotify(key, code, errorMessage);\n        }\n        let messageFormat;\n        // Hot path that avoids creating an `IntlMessageFormat` instance\n        const plainMessage = getPlainMessage(message, values);\n        if (plainMessage) return plainMessage;\n        // Lazy init the message formatter for better tree\n        // shaking in case message formatting is not used.\n        if (!formatters.getMessageFormat) {\n            formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n        }\n        try {\n            messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n                formatters: {\n                    ...formatters,\n                    getDateTimeFormat (locales, options) {\n                        // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                        return formatters.getDateTimeFormat(locales, {\n                            timeZone,\n                            ...options\n                        });\n                    }\n                }\n            });\n        } catch (error) {\n            const thrownError = error;\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? ` (${thrownError.originalMessage})` : \"\"), fallback);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            values ? prepareTranslationValues(values) : values);\n            if (formattedMessage == null) {\n                throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"}`);\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message, fallback);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Custom formats for numbers, dates and times. */ formats, _fallback) {\n        const result = translateBaseFn(key, values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : \"messages\"} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats, _fallback)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats, _fallback);\n        if (typeof result !== \"string\") {\n            const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (hasMessagesError) {\n            onError(messagesOrError);\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    translateFn.has = (key)=>{\n        if (hasMessagesError) {\n            return false;\n        }\n        try {\n            resolvePath(locale, messagesOrError, key, namespace);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n    const { _cache: cache = createCache(), _formatters: formatters = createIntlFormatters(cache), formats, locale, onError = defaultOnError, timeZone: globalTimeZone } = props;\n    function applyTimeZone(options) {\n        if (!options?.timeZone) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats?.[formatName];\n            if (!options) {\n                const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        if (overrides) {\n            options = {\n                ...options,\n                ...overrides\n            };\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n        } catch  {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(start, end, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions, overrides) {\n        return getFormattedValue(formatOrOptions, overrides, formats?.number, (options)=>formatters.getNumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        // Only read when necessary to avoid triggering a `dynamicIO` error\n        // unnecessarily (`now` is only needed for `format.relativeTime`)\n        if (props.now) {\n            return props.now;\n        } else {\n            onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n            return new Date();\n        }\n    }\n    function relativeTime(date, nowOrOptions) {\n        try {\n            let nowDate, unit;\n            const opts = {};\n            if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n                nowDate = new Date(nowOrOptions);\n            } else if (nowOrOptions) {\n                if (nowOrOptions.now != null) {\n                    nowDate = new Date(nowOrOptions.now);\n                } else {\n                    nowDate = getGlobalNow();\n                }\n                unit = nowOrOptions.unit;\n                opts.style = nowOrOptions.style;\n                // @ts-expect-error -- Types are slightly outdated\n                opts.numberingSystem = nowOrOptions.numberingSystem;\n            }\n            if (!nowDate) {\n                nowDate = getGlobalNow();\n            }\n            const dateDate = new Date(date);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            if (!unit) {\n                unit = resolveRelativeTimeUnit(seconds);\n            }\n            // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n            // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n            // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n            // not desired, as the given dates might cross a threshold were the\n            // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n            // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n            // case. By using `always` we can ensure correct output. The only exception\n            // is the formatting of times <1 second as \"now\".\n            opts.numeric = unit === \"second\" ? \"auto\" : \"always\";\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n        } catch (error) {\n            onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions, overrides) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, overrides, formats?.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach(([key, messageOrMessages])=>{\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += ` (at ${parentPath})`;\n            invalidKeyLabels.push(keyLabel);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? \"key\" : \"keys\"}: ${invalidKeyLabels.join(\", \")}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig({ formats, getMessageFallback, messages, onError, ...rest }) {\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        formats: formats || undefined,\n        messages: messages || undefined,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VzZS1pbnRsQDQuNS44X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1DSURWTVMyRS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxrQkFBa0JDO0lBQ3RCQyxZQUFZQyxJQUFJLEVBQUVDLGVBQWUsQ0FBRTtRQUNqQyxJQUFJQyxVQUFVRjtRQUNkLElBQUlDLGlCQUFpQjtZQUNuQkMsV0FBVyxPQUFPRDtRQUNwQjtRQUNBLEtBQUssQ0FBQ0M7UUFDTixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJQyxpQkFBaUI7WUFDbkIsSUFBSSxDQUFDQSxlQUFlLEdBQUdBO1FBQ3pCO0lBQ0Y7QUFDRjtBQUVBLElBQUlFLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFvQixHQUFHO0lBQ3JDQSxhQUFhLENBQUMsa0JBQWtCLEdBQUc7SUFDbkNBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxtQkFBbUIsR0FBRztJQUNwQyxPQUFPQTtBQUNULEVBQUVBLGlCQUFpQixDQUFDO0FBRXBCOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGtDQUFrQ0MsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLFFBQVE7SUFDL0UsTUFBTUMsaUJBQWlCaEIsaUVBQWlCQSxDQUFDaUIsT0FBTyxDQUFDQyxJQUFJO0lBQ3JELE1BQU1DLGlCQUFpQm5CLGlFQUFpQkEsQ0FBQ2lCLE9BQU8sQ0FBQ0csSUFBSTtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEIsR0FBR1IsZUFBZVMsUUFBUTtR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Q3BCcEIsVUFBVUEsWUFBWW9CO1FBQ3RCTSxTQUFTK0c7UUFDVGhILG9CQUFvQmlIO0lBQ3RCO0FBQ0Y7QUFFK08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VzZS1pbnRsQDQuNS44X3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1DSURWTVMyRS5qcz9hZTUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEludGxNZXNzYWdlRm9ybWF0IH0gZnJvbSAnaW50bC1tZXNzYWdlZm9ybWF0JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50LCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtZW1vaXplLCBzdHJhdGVnaWVzIH0gZnJvbSAnQGZvcm1hdGpzL2Zhc3QtbWVtb2l6ZSc7XG5cbmNsYXNzIEludGxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgb3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIG1lc3NhZ2UgKz0gJzogJyArIG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIEludGxFcnJvckNvZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEludGxFcnJvckNvZGUpIHtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfTUVTU0FHRVwiXSA9IFwiTUlTU0lOR19NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX0ZPUk1BVFwiXSA9IFwiTUlTU0lOR19GT1JNQVRcIjtcbiAgSW50bEVycm9yQ29kZVtcIkVOVklST05NRU5UX0ZBTExCQUNLXCJdID0gXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX1BBVEhcIl0gPSBcIklOU1VGRklDSUVOVF9QQVRIXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX01FU1NBR0VcIl0gPSBcIklOVkFMSURfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9LRVlcIl0gPSBcIklOVkFMSURfS0VZXCI7XG4gIEludGxFcnJvckNvZGVbXCJGT1JNQVRUSU5HX0VSUk9SXCJdID0gXCJGT1JNQVRUSU5HX0VSUk9SXCI7XG4gIHJldHVybiBJbnRsRXJyb3JDb2RlO1xufShJbnRsRXJyb3JDb2RlIHx8IHt9KTtcblxuLyoqXG4gKiBgaW50bC1tZXNzYWdlZm9ybWF0YCB1c2VzIHNlcGFyYXRlIGtleXMgZm9yIGBkYXRlYCBhbmQgYHRpbWVgLCBidXQgdGhlcmUnc1xuICogb25seSBvbmUgbmF0aXZlIEFQSTogYEludGwuRGF0ZVRpbWVGb3JtYXRgLiBBZGRpdGlvbmFsbHkgeW91IG1pZ2h0IHdhbnQgdG9cbiAqIGluY2x1ZGUgYm90aCBhIHRpbWUgYW5kIGEgZGF0ZSBpbiBhIHZhbHVlLCB0aGVyZWZvcmUgdGhlIHNlcGFyYXRpb24gZG9lc24ndFxuICogc2VlbSBzbyB1c2VmdWwuIFdlIG9mZmVyIGEgc2luZ2xlIGBkYXRlVGltZWAgbmFtZXNwYWNlIGluc3RlYWQsIGJ1dCB3ZSBoYXZlXG4gKiB0byBjb252ZXJ0IHRoZSBmb3JtYXQgYmVmb3JlIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGNhbiBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoZ2xvYmFsRm9ybWF0cywgaW5saW5lRm9ybWF0cywgdGltZVpvbmUpIHtcbiAgY29uc3QgbWZEYXRlRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdC5mb3JtYXRzLmRhdGU7XG4gIGNvbnN0IG1mVGltZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXQuZm9ybWF0cy50aW1lO1xuICBjb25zdCBkYXRlVGltZUZvcm1hdHMgPSB7XG4gICAgLi4uZ2xvYmFsRm9ybWF0cz8uZGF0ZVRpbWUsXG4gICAgLi4uaW5saW5lRm9ybWF0cz8uZGF0ZVRpbWVcbiAgfTtcbiAgY29uc3QgYWxsRm9ybWF0cyA9IHtcbiAgICBkYXRlOiB7XG4gICAgICAuLi5tZkRhdGVEZWZhdWx0cyxcbiAgICAgIC4uLmRhdGVUaW1lRm9ybWF0c1xuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgLi4ubWZUaW1lRGVmYXVsdHMsXG4gICAgICAuLi5kYXRlVGltZUZvcm1hdHNcbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgLi4uZ2xvYmFsRm9ybWF0cz8ubnVtYmVyLFxuICAgICAgLi4uaW5saW5lRm9ybWF0cz8ubnVtYmVyXG4gICAgfVxuICAgIC8vIChsaXN0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUNVIG1lc3NhZ2VzKVxuICB9O1xuICBpZiAodGltZVpvbmUpIHtcbiAgICAvLyBUaGUgb25seSB3YXkgdG8gc2V0IGEgdGltZSB6b25lIHdpdGggYGludGwtbWVzc2FnZWZvcm1hdGAgaXMgdG8gbWVyZ2UgaXQgaW50byB0aGUgZm9ybWF0c1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9ibG9iLzgyNTZjNTI3MTUwNWNmMjYwNmU0OGUzYzk3ZWNkZDE2ZWRlNGYxYjUvcGFja2FnZXMvaW50bC9zcmMvbWVzc2FnZS50cyNMMTVcbiAgICBbJ2RhdGUnLCAndGltZSddLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IGFsbEZvcm1hdHNbcHJvcGVydHldO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZm9ybWF0cykpIHtcbiAgICAgICAgZm9ybWF0c1trZXldID0ge1xuICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFsbEZvcm1hdHM7XG59XG5cbmZ1bmN0aW9uIGpvaW5QYXRoKC4uLnBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoQm9vbGVhbikuam9pbignLicpO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGRlZmF1bHRzIHRoYXQgYXJlIHVzZWQgZm9yIGFsbCBlbnRyeSBwb2ludHMgaW50byB0aGUgY29yZS5cbiAqIFNlZSBhbHNvIGBJbml0aWFsaXplZEludGxDb25maWd1cmF0aW9uYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrKHByb3BzKSB7XG4gIHJldHVybiBqb2luUGF0aChwcm9wcy5uYW1lc3BhY2UsIHByb3BzLmtleSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWU6IHt9LFxuICAgIG51bWJlcjoge30sXG4gICAgbWVzc2FnZToge30sXG4gICAgcmVsYXRpdmVUaW1lOiB7fSxcbiAgICBwbHVyYWxSdWxlczoge30sXG4gICAgbGlzdDoge30sXG4gICAgZGlzcGxheU5hbWVzOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTWVtb0NhY2hlKHN0b3JlKSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgIHJldHVybiBzdG9yZVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtZW1vRm4oZm4sIGNhY2hlKSB7XG4gIHJldHVybiBtZW1vaXplKGZuLCB7XG4gICAgY2FjaGU6IGNyZWF0ZU1lbW9DYWNoZShjYWNoZSksXG4gICAgc3RyYXRlZ3k6IHN0cmF0ZWdpZXMudmFyaWFkaWNcbiAgfSk7XG59XG5mdW5jdGlvbiBtZW1vQ29uc3RydWN0b3IoQ29uc3RydWN0b3JGbiwgY2FjaGUpIHtcbiAgcmV0dXJuIG1lbW9GbigoLi4uYXJncykgPT4gbmV3IENvbnN0cnVjdG9yRm4oLi4uYXJncyksIGNhY2hlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSB7XG4gIGNvbnN0IGdldERhdGVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuRGF0ZVRpbWVGb3JtYXQsIGNhY2hlLmRhdGVUaW1lKTtcbiAgY29uc3QgZ2V0TnVtYmVyRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTnVtYmVyRm9ybWF0LCBjYWNoZS5udW1iZXIpO1xuICBjb25zdCBnZXRQbHVyYWxSdWxlcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLlBsdXJhbFJ1bGVzLCBjYWNoZS5wbHVyYWxSdWxlcyk7XG4gIGNvbnN0IGdldFJlbGF0aXZlVGltZUZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLlJlbGF0aXZlVGltZUZvcm1hdCwgY2FjaGUucmVsYXRpdmVUaW1lKTtcbiAgY29uc3QgZ2V0TGlzdEZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkxpc3RGb3JtYXQsIGNhY2hlLmxpc3QpO1xuICBjb25zdCBnZXREaXNwbGF5TmFtZXMgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EaXNwbGF5TmFtZXMsIGNhY2hlLmRpc3BsYXlOYW1lcyk7XG4gIHJldHVybiB7XG4gICAgZ2V0RGF0ZVRpbWVGb3JtYXQsXG4gICAgZ2V0TnVtYmVyRm9ybWF0LFxuICAgIGdldFBsdXJhbFJ1bGVzLFxuICAgIGdldFJlbGF0aXZlVGltZUZvcm1hdCxcbiAgICBnZXRMaXN0Rm9ybWF0LFxuICAgIGdldERpc3BsYXlOYW1lc1xuICB9O1xufVxuXG4vLyBQbGFjZWQgaGVyZSBmb3IgaW1wcm92ZWQgdHJlZSBzaGFraW5nLiBTb21laG93IHdoZW4gdGhpcyBpcyBwbGFjZWQgaW5cbi8vIGBmb3JtYXR0ZXJzLnRzeGAsIHRoZW4gaXQgY2FuJ3QgYmUgc2hha2VuIG9mZiBmcm9tIGBuZXh0LWludGxgLlxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUZvcm1hdHRlcihjYWNoZSwgaW50bEZvcm1hdHRlcnMpIHtcbiAgY29uc3QgZ2V0TWVzc2FnZUZvcm1hdCA9IG1lbW9GbigoLi4uYXJncykgPT4gbmV3IEludGxNZXNzYWdlRm9ybWF0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIHtcbiAgICBmb3JtYXR0ZXJzOiBpbnRsRm9ybWF0dGVycyxcbiAgICAuLi5hcmdzWzNdXG4gIH0pLCBjYWNoZS5tZXNzYWdlKTtcbiAgcmV0dXJuIGdldE1lc3NhZ2VGb3JtYXQ7XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSkge1xuICBjb25zdCBmdWxsS2V5ID0gam9pblBhdGgobmFtZXNwYWNlLCBrZXkpO1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyBhdmFpbGFibGUgYXQgXFxgJHtuYW1lc3BhY2V9XFxgLmAgKTtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzO1xuICBrZXkuc3BsaXQoJy4nKS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBtZXNzYWdlW3BhcnRdO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAocGFydCA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBcXGAke2Z1bGxLZXl9XFxgIGluIG1lc3NhZ2VzIGZvciBsb2NhbGUgXFxgJHtsb2NhbGV9XFxgLmAgKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG5leHQ7XG4gIH0pO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIHtcbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy8xNDY3XG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWVzID0ge307XG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICBsZXQgdHJhbnNmb3JtZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJhbnNmb3JtZWQgPSBjaHVua3MgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZShjaHVua3MpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KHJlc3VsdCkgPyAvKiNfX1BVUkVfXyovY2xvbmVFbGVtZW50KHJlc3VsdCwge1xuICAgICAgICAgIGtleToga2V5ICsgaW5kZXgrK1xuICAgICAgICB9KSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gdmFsdWU7XG4gICAgfVxuICAgIHRyYW5zZm9ybWVkVmFsdWVzW2tleV0gPSB0cmFuc2Zvcm1lZDtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzT3JFcnJvcihsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIHdlcmUgY29uZmlndXJlZC5gICk7XG4gICAgfVxuICAgIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gbmFtZXNwYWNlID8gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSA6IG1lc3NhZ2VzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIGZvciBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgIGZvdW5kLmAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHJpZXZlZE1lc3NhZ2VzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGludGxFcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHJldHVybiBpbnRsRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBsYWluTWVzc2FnZShjYW5kaWRhdGUsIHZhbHVlcykge1xuICAvLyBUbyBpbXByb3ZlIHJ1bnRpbWUgcGVyZm9ybWFuY2UsIG9ubHkgY29tcGlsZSBtZXNzYWdlIGlmOlxuICByZXR1cm4gKFxuICAgIC8vIDEuIFZhbHVlcyBhcmUgcHJvdmlkZWRcbiAgICB2YWx1ZXMgfHxcbiAgICAvLyAyLiBUaGVyZSBhcmUgZXNjYXBlZCBicmFjZXMgKGUuZy4gXCIne25hbWUnfVwiKVxuICAgIC8nW3t9XS8udGVzdChjYW5kaWRhdGUpIHx8XG4gICAgLy8gMy4gVGhlcmUgYXJlIG1pc3NpbmcgYXJndW1lbnRzIG9yIHRhZ3MgKGRldi1vbmx5IGVycm9yIGhhbmRsaW5nKVxuICAgIC88fHsvLnRlc3QoY2FuZGlkYXRlKSA/IHVuZGVmaW5lZCAvLyBDb21waWxlXG4gICAgOiBjYW5kaWRhdGUgLy8gRG9uJ3QgY29tcGlsZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3IoY29uZmlnKSB7XG4gIGNvbnN0IG1lc3NhZ2VzT3JFcnJvciA9IGdldE1lc3NhZ2VzT3JFcnJvcihjb25maWcubG9jYWxlLCBjb25maWcubWVzc2FnZXMsIGNvbmZpZy5uYW1lc3BhY2UpO1xuICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5jb25maWcsXG4gICAgbWVzc2FnZXNPckVycm9yXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgY2FjaGUsXG4gIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gIGZvcm1hdHRlcnMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayA9IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gIGxvY2FsZSxcbiAgbWVzc2FnZXNPckVycm9yLFxuICBuYW1lc3BhY2UsXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IGhhc01lc3NhZ2VzRXJyb3IgPSBtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBJbnRsRXJyb3I7XG4gIGZ1bmN0aW9uIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgbWVzc2FnZSwgZmFsbGJhY2spIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoY29kZSwgbWVzc2FnZSk7XG4gICAgb25FcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGZhbGxiYWNrID8/IGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICBlcnJvcixcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUJhc2VGbigvKiogVXNlIGEgZG90IHRvIGluZGljYXRlIGEgbGV2ZWwgb2YgbmVzdGluZyAoZS5nLiBgbmFtZXNwYWNlLm5lc3RlZExhYmVsYCkuICovXG4gIGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgLyoqIFByb3ZpZGUgY3VzdG9tIGZvcm1hdHMgZm9yIG51bWJlcnMsIGRhdGVzIGFuZCB0aW1lcy4gKi9cbiAgZm9ybWF0cywgX2ZhbGxiYWNrKSB7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBfZmFsbGJhY2s7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICBtZXNzYWdlID0gZmFsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVycm9yKG1lc3NhZ2VzT3JFcnJvcik7XG4gICAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGZhbGxiYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlLCBmYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgbGV0IGNvZGUsIGVycm9yTWVzc2FnZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgIGNvZGUgPSBJbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRTtcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBNZXNzYWdlIGF0IFxcYCR7am9pblBhdGgobmFtZXNwYWNlLCBrZXkpfVxcYCByZXNvbHZlZCB0byBhbiBhcnJheSwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvdHJhbnNsYXRpb25zI2FycmF5cy1vZi1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgPSBJbnRsRXJyb3JDb2RlLklOU1VGRklDSUVOVF9QQVRIO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBcXGAuXFxgIHRvIHJldHJpZXZlIG5lc3RlZCBtZXNzYWdlcy4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL3RyYW5zbGF0aW9ucyNzdHJ1Y3R1cmluZy1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuXG4gICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG5cbiAgICAvLyBMYXp5IGluaXQgdGhlIG1lc3NhZ2UgZm9ybWF0dGVyIGZvciBiZXR0ZXIgdHJlZVxuICAgIC8vIHNoYWtpbmcgaW4gY2FzZSBtZXNzYWdlIGZvcm1hdHRpbmcgaXMgbm90IHVzZWQuXG4gICAgaWYgKCFmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCA9IGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGZvcm1hdHRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBmb3JtYXRzLCB0aW1lWm9uZSksIHtcbiAgICAgICAgZm9ybWF0dGVyczoge1xuICAgICAgICAgIC4uLmZvcm1hdHRlcnMsXG4gICAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy80Mjc5XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB0aHJvd25FcnJvciA9IGVycm9yO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIHRocm93bkVycm9yLm1lc3NhZ2UgKyAoJ29yaWdpbmFsTWVzc2FnZScgaW4gdGhyb3duRXJyb3IgPyBgICgke3Rocm93bkVycm9yLm9yaWdpbmFsTWVzc2FnZX0pYCA6ICcnKSAsIGZhbGxiYWNrKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSBtZXNzYWdlRm9ybWF0LmZvcm1hdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGludGwtbWVzc2FnZWZvcm1hdGAgZXhwZWN0cyBhIGRpZmZlcmVudCBmb3JtYXRcbiAgICAgIC8vIGZvciByaWNoIHRleHQgZWxlbWVudHMgc2luY2UgYSByZWNlbnQgbWlub3IgdXBkYXRlLiBUaGlzXG4gICAgICAvLyBuZWVkcyB0byBiZSBldmFsdWF0ZWQgaW4gZGV0YWlsLCBwb3NzaWJseSBhbHNvIGluIHJlZ2FyZHNcbiAgICAgIC8vIHRvIGJlIGFibGUgdG8gZm9ybWF0IHRvIHBhcnRzLlxuICAgICAgdmFsdWVzID8gcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHZhbHVlcykgOiB2YWx1ZXMpO1xuICAgICAgaWYgKGZvcm1hdHRlZE1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmb3JtYXQgXFxgJHtrZXl9XFxgIGluICR7bmFtZXNwYWNlID8gYG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGBgIDogJ21lc3NhZ2VzJ31gICk7XG4gICAgICB9XG5cbiAgICAgIC8vIExpbWl0IHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgdG8gcmV0dXJuIHN0cmluZ3Mgb3IgUmVhY3QgZWxlbWVudHNcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQoZm9ybWF0dGVkTWVzc2FnZSkgfHxcbiAgICAgIC8vIEFycmF5cyBvZiBSZWFjdCBlbGVtZW50c1xuICAgICAgQXJyYXkuaXNBcnJheShmb3JtYXR0ZWRNZXNzYWdlKSB8fCB0eXBlb2YgZm9ybWF0dGVkTWVzc2FnZSA9PT0gJ3N0cmluZycgPyBmb3JtYXR0ZWRNZXNzYWdlIDogU3RyaW5nKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UsIGZhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBDdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzLCBfZmFsbGJhY2spIHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LCB2YWx1ZXMsIGZvcm1hdHMsIF9mYWxsYmFjayk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgYFRoZSBtZXNzYWdlIFxcYCR7a2V5fVxcYCBpbiAke25hbWVzcGFjZSA/IGBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgYCA6ICdtZXNzYWdlcyd9IGRpZG4ndCByZXNvbHZlIHRvIGEgc3RyaW5nLiBJZiB5b3Ugd2FudCB0byBmb3JtYXQgcmljaCB0ZXh0LCB1c2UgXFxgdC5yaWNoXFxgIGluc3RlYWQuYCApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyYW5zbGF0ZUZuLnJpY2ggPSB0cmFuc2xhdGVCYXNlRm47XG5cbiAgLy8gQXVnbWVudCBgdHJhbnNsYXRlQmFzZUZuYCB0byByZXR1cm4gcGxhaW4gc3RyaW5nc1xuICB0cmFuc2xhdGVGbi5tYXJrdXAgPSAoa2V5LCB2YWx1ZXMsIGZvcm1hdHMsIF9mYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgTWFya3VwVHJhbnNsYXRpb25WYWx1ZXNgIGlzIHByYWN0aWNhbGx5IGEgc3ViIHR5cGVcbiAgICAvLyBvZiBgUmljaFRyYW5zbGF0aW9uVmFsdWVzYCBidXQgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggaGVyZS5cbiAgICB2YWx1ZXMsIGZvcm1hdHMsIF9mYWxsYmFjayk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBcImB0Lm1hcmt1cGAgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGF0IHJlY2VpdmUgYW5kIHJldHVybiBzdHJpbmdzLlxcblxcbkUuZy4gdC5tYXJrdXAoJ21hcmt1cCcsIHtiOiAoY2h1bmtzKSA9PiBgPGI+JHtjaHVua3N9PC9iPmB9KVwiKTtcbiAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHRyYW5zbGF0ZUZuLnJhdyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobWVzc2FnZXNPckVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9O1xuICB0cmFuc2xhdGVGbi5oYXMgPSBrZXkgPT4ge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzT3JFcnJvciwga2V5LCBuYW1lc3BhY2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhbnNsYXRlRm47XG59XG5cbi8qKlxuICogRm9yIHRoZSBzdHJpY3RseSB0eXBlZCBtZXNzYWdlcyB0byB3b3JrIHdlIGhhdmUgdG8gd3JhcCB0aGUgbmFtZXNwYWNlIGludG9cbiAqIGEgbWFuZGF0b3J5IHByZWZpeC4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCkge1xuICByZXR1cm4gbmFtZXNwYWNlID09PSBuYW1lc3BhY2VQcmVmaXggPyB1bmRlZmluZWQgOiBuYW1lc3BhY2Uuc2xpY2UoKG5hbWVzcGFjZVByZWZpeCArICcuJykubGVuZ3RoKTtcbn1cblxuY29uc3QgU0VDT05EID0gMTtcbmNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xuY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwO1xuY29uc3QgREFZID0gSE9VUiAqIDI0O1xuY29uc3QgV0VFSyA9IERBWSAqIDc7XG5jb25zdCBNT05USCA9IERBWSAqICgzNjUgLyAxMik7IC8vIEFwcHJveGltYXRpb25cbmNvbnN0IFFVQVJURVIgPSBNT05USCAqIDM7XG5jb25zdCBZRUFSID0gREFZICogMzY1O1xuY29uc3QgVU5JVF9TRUNPTkRTID0ge1xuICBzZWNvbmQ6IFNFQ09ORCxcbiAgc2Vjb25kczogU0VDT05ELFxuICBtaW51dGU6IE1JTlVURSxcbiAgbWludXRlczogTUlOVVRFLFxuICBob3VyOiBIT1VSLFxuICBob3VyczogSE9VUixcbiAgZGF5OiBEQVksXG4gIGRheXM6IERBWSxcbiAgd2VlazogV0VFSyxcbiAgd2Vla3M6IFdFRUssXG4gIG1vbnRoOiBNT05USCxcbiAgbW9udGhzOiBNT05USCxcbiAgcXVhcnRlcjogUVVBUlRFUixcbiAgcXVhcnRlcnM6IFFVQVJURVIsXG4gIHllYXI6IFlFQVIsXG4gIHllYXJzOiBZRUFSXG59O1xuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykge1xuICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKHNlY29uZHMpO1xuICBpZiAoYWJzVmFsdWUgPCBNSU5VVEUpIHtcbiAgICByZXR1cm4gJ3NlY29uZCc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBIT1VSKSB7XG4gICAgcmV0dXJuICdtaW51dGUnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgREFZKSB7XG4gICAgcmV0dXJuICdob3VyJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFdFRUspIHtcbiAgICByZXR1cm4gJ2RheSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBNT05USCkge1xuICAgIHJldHVybiAnd2Vlayc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBZRUFSKSB7XG4gICAgcmV0dXJuICdtb250aCc7XG4gIH1cbiAgcmV0dXJuICd5ZWFyJztcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpIHtcbiAgLy8gV2UgaGF2ZSB0byByb3VuZCB0aGUgcmVzdWx0aW5nIHZhbHVlcywgYXMgYEludGwuUmVsYXRpdmVUaW1lRm9ybWF0YFxuICAvLyB3aWxsIGluY2x1ZGUgZnJhY3Rpb25zIGxpa2UgJzIuMSBob3VycyBhZ28nLlxuICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzIC8gVU5JVF9TRUNPTkRTW3VuaXRdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgX2NhY2hlOiBjYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgX2Zvcm1hdHRlcnM6IGZvcm1hdHRlcnMgPSBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSksXG4gICAgZm9ybWF0cyxcbiAgICBsb2NhbGUsXG4gICAgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLFxuICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICB9ID0gcHJvcHM7XG4gIGZ1bmN0aW9uIGFwcGx5VGltZVpvbmUob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucz8udGltZVpvbmUpIHtcbiAgICAgIGlmIChnbG9iYWxUaW1lWm9uZSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgYFRoZSBcXGB0aW1lWm9uZVxcYCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL2NvbmZpZ3VyYXRpb24jdGltZS16b25lYCApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGZvcm1hdE9yT3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGZvcm1hdE5hbWUgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gdHlwZUZvcm1hdHM/Lltmb3JtYXROYW1lXTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5NSVNTSU5HX0ZPUk1BVCwgYEZvcm1hdCBcXGAke2Zvcm1hdE5hbWV9XFxgIGlzIG5vdCBhdmFpbGFibGUuYCApO1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmb3JtYXRPck9wdGlvbnM7XG4gICAgfVxuICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLm92ZXJyaWRlc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIHR5cGVGb3JtYXRzLCBmb3JtYXR0ZXIsIGdldEZhbGxiYWNrKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZSh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/LmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIG9wdGlvbnMgPSBhcHBseVRpbWVab25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpO1xuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lUmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/LmRhdGVUaW1lLCBvcHRpb25zID0+IHtcbiAgICAgIG9wdGlvbnMgPSBhcHBseVRpbWVab25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9LCAoKSA9PiBbZGF0ZVRpbWUoc3RhcnQpLCBkYXRlVGltZShlbmQpXS5qb2luKCfigInigJPigIknKSk7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8ubnVtYmVyLCBvcHRpb25zID0+IGZvcm1hdHRlcnMuZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsTm93KCkge1xuICAgIC8vIE9ubHkgcmVhZCB3aGVuIG5lY2Vzc2FyeSB0byBhdm9pZCB0cmlnZ2VyaW5nIGEgYGR5bmFtaWNJT2AgZXJyb3JcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IChgbm93YCBpcyBvbmx5IG5lZWRlZCBmb3IgYGZvcm1hdC5yZWxhdGl2ZVRpbWVgKVxuICAgIGlmIChwcm9wcy5ub3cpIHtcbiAgICAgIHJldHVybiBwcm9wcy5ub3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlIFxcYG5vd1xcYCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIHRvIFxcYHJlbGF0aXZlVGltZVxcYCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZCwgdGhlcmVmb3JlIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkIGFzIGEgZmFsbGJhY2suIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9kYXRlcy10aW1lcyNyZWxhdGl2ZS10aW1lcy11c2Vub3dgICkpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShkYXRlLCBub3dPck9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IG5vd0RhdGUsIHVuaXQ7XG4gICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICBpZiAobm93T3JPcHRpb25zIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAobm93T3JPcHRpb25zKSB7XG4gICAgICAgIGlmIChub3dPck9wdGlvbnMubm93ICE9IG51bGwpIHtcbiAgICAgICAgICBub3dEYXRlID0gbmV3IERhdGUobm93T3JPcHRpb25zLm5vdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHVuaXQgPSBub3dPck9wdGlvbnMudW5pdDtcbiAgICAgICAgb3B0cy5zdHlsZSA9IG5vd09yT3B0aW9ucy5zdHlsZTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBUeXBlcyBhcmUgc2xpZ2h0bHkgb3V0ZGF0ZWRcbiAgICAgICAgb3B0cy5udW1iZXJpbmdTeXN0ZW0gPSBub3dPck9wdGlvbnMubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgfVxuICAgICAgaWYgKCFub3dEYXRlKSB7XG4gICAgICAgIG5vd0RhdGUgPSBnZXRHbG9iYWxOb3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGVEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICBjb25zdCBzZWNvbmRzID0gKGRhdGVEYXRlLmdldFRpbWUoKSAtIG5vd0RhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgICBpZiAoIXVuaXQpIHtcbiAgICAgICAgdW5pdCA9IHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBgbnVtZXJpYzogJ2F1dG8nYCBjYW4gdGhlb3JldGljYWxseSBwcm9kdWNlIG91dHB1dCBsaWtlIFwieWVzdGVyZGF5XCIsXG4gICAgICAvLyBidXQgaXQgb25seSB3b3JrcyB3aXRoIGludGVnZXJzLiBFLmcuIC0xIGRheSB3aWxsIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCAtMS4xIGRheXMgd2lsbCBwcm9kdWNlIFwiLTEuMSBkYXlzXCIuIFJvdW5kaW5nIGJlZm9yZSBmb3JtYXR0aW5nIGlzXG4gICAgICAvLyBub3QgZGVzaXJlZCwgYXMgdGhlIGdpdmVuIGRhdGVzIG1pZ2h0IGNyb3NzIGEgdGhyZXNob2xkIHdlcmUgdGhlXG4gICAgICAvLyBvdXRwdXQgaXNuJ3QgY29ycmVjdCBhbnltb3JlLiBFeGFtcGxlOiAyMDI0LTAxLTA4VDIzOjAwOjAwLjAwMFogYW5kXG4gICAgICAvLyAyMDI0LTAxLTA4VDAxOjAwOjAwLjAwMFogd291bGQgcHJvZHVjZSBcInllc3RlcmRheVwiLCB3aGljaCBpcyBub3QgdGhlXG4gICAgICAvLyBjYXNlLiBCeSB1c2luZyBgYWx3YXlzYCB3ZSBjYW4gZW5zdXJlIGNvcnJlY3Qgb3V0cHV0LiBUaGUgb25seSBleGNlcHRpb25cbiAgICAgIC8vIGlzIHRoZSBmb3JtYXR0aW5nIG9mIHRpbWVzIDwxIHNlY29uZCBhcyBcIm5vd1wiLlxuICAgICAgb3B0cy5udW1lcmljID0gdW5pdCA9PT0gJ3NlY29uZCcgPyAnYXV0bycgOiAnYWx3YXlzJztcbiAgICAgIGNvbnN0IHZhbHVlID0gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXRSZWxhdGl2ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRzKS5mb3JtYXQodmFsdWUsIHVuaXQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gU3RyaW5nKGRhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsaXN0KHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRWYWx1ZSA9IFtdO1xuICAgIGNvbnN0IHJpY2hWYWx1ZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBgZm9ybWF0VG9QYXJ0c2Agb25seSBhY2NlcHRzIHN0cmluZ3MsIHRoZXJlZm9yZSB3ZSBoYXZlIHRvIHRlbXBvcmFyaWx5XG4gICAgLy8gcmVwbGFjZSBSZWFjdCBlbGVtZW50cyB3aXRoIGEgcGxhY2Vob2xkZXIgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZVxuICAgIC8vIHRoZSBvcmlnaW5hbCB2YWx1ZSBhZnRlcndhcmRzLlxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICBsZXQgc2VyaWFsaXplZEl0ZW07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gU3RyaW5nKGluZGV4KTtcbiAgICAgICAgcmljaFZhbHVlcy5zZXQoc2VyaWFsaXplZEl0ZW0sIGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaXRlbSk7XG4gICAgICB9XG4gICAgICBzZXJpYWxpemVkVmFsdWUucHVzaChzZXJpYWxpemVkSXRlbSk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/Lmxpc3QsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgcmljaFZhbHVlcy5zaXplYCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGUsIGJ1dCBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHRoZSBtZWFuaW5nIG9mIHRoaXMgY29ycmVjdGx5XG4gICAgb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmb3JtYXR0ZXJzLmdldExpc3RGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRUb1BhcnRzKHNlcmlhbGl6ZWRWYWx1ZSkubWFwKHBhcnQgPT4gcGFydC50eXBlID09PSAnbGl0ZXJhbCcgPyBwYXJ0LnZhbHVlIDogcmljaFZhbHVlcy5nZXQocGFydC52YWx1ZSkgfHwgcGFydC52YWx1ZSk7XG4gICAgICBpZiAocmljaFZhbHVlcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9LCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGVUaW1lLFxuICAgIG51bWJlcixcbiAgICByZWxhdGl2ZVRpbWUsXG4gICAgbGlzdCxcbiAgICBkYXRlVGltZVJhbmdlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBwYXJlbnRQYXRoKSB7XG4gIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2VzKS5mb3JFYWNoKChba2V5LCBtZXNzYWdlT3JNZXNzYWdlc10pID0+IHtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGxldCBrZXlMYWJlbCA9IGtleTtcbiAgICAgIGlmIChwYXJlbnRQYXRoKSBrZXlMYWJlbCArPSBgIChhdCAke3BhcmVudFBhdGh9KWA7XG4gICAgICBpbnZhbGlkS2V5TGFiZWxzLnB1c2goa2V5TGFiZWwpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKG1lc3NhZ2VPck1lc3NhZ2VzICE9IG51bGwgJiYgdHlwZW9mIG1lc3NhZ2VPck1lc3NhZ2VzID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZU9yTWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIGpvaW5QYXRoKHBhcmVudFBhdGgsIGtleSkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBvbkVycm9yKSB7XG4gIGNvbnN0IGludmFsaWRLZXlMYWJlbHMgPSBbXTtcbiAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMpO1xuICBpZiAoaW52YWxpZEtleUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuSU5WQUxJRF9LRVksIGBOYW1lc3BhY2Uga2V5cyBjYW4gbm90IGNvbnRhaW4gdGhlIGNoYXJhY3RlciBcIi5cIiBhcyB0aGlzIGlzIHVzZWQgdG8gZXhwcmVzcyBuZXN0aW5nLiBQbGVhc2UgcmVtb3ZlIGl0IG9yIHJlcGxhY2UgaXQgd2l0aCBhbm90aGVyIGNoYXJhY3Rlci5cblxuSW52YWxpZCAke2ludmFsaWRLZXlMYWJlbHMubGVuZ3RoID09PSAxID8gJ2tleScgOiAna2V5cyd9OiAke2ludmFsaWRLZXlMYWJlbHMuam9pbignLCAnKX1cblxuSWYgeW91J3JlIG1pZ3JhdGluZyBmcm9tIGEgZmxhdCBzdHJ1Y3R1cmUsIHlvdSBjYW4gY29udmVydCB5b3VyIG1lc3NhZ2VzIGFzIGZvbGxvd3M6XG5cbmltcG9ydCB7c2V0fSBmcm9tIFwibG9kYXNoXCI7XG5cbmNvbnN0IGlucHV0ID0ge1xuICBcIm9uZS5vbmVcIjogXCIxLjFcIixcbiAgXCJvbmUudHdvXCI6IFwiMS4yXCIsXG4gIFwidHdvLm9uZS5vbmVcIjogXCIyLjEuMVwiXG59O1xuXG5jb25zdCBvdXRwdXQgPSBPYmplY3QuZW50cmllcyhpbnB1dCkucmVkdWNlKFxuICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHNldChhY2MsIGtleSwgdmFsdWUpLFxuICB7fVxuKTtcblxuLy8gT3V0cHV0OlxuLy9cbi8vIHtcbi8vICAgXCJvbmVcIjoge1xuLy8gICAgIFwib25lXCI6IFwiMS4xXCIsXG4vLyAgICAgXCJ0d29cIjogXCIxLjJcIlxuLy8gICB9LFxuLy8gICBcInR3b1wiOiB7XG4vLyAgICAgXCJvbmVcIjoge1xuLy8gICAgICAgXCJvbmVcIjogXCIyLjEuMVwiXG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5gICkpO1xuICB9XG59XG5cbi8qKlxuICogRW5oYW5jZXMgdGhlIGluY29taW5nIHByb3BzIHdpdGggZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDb25maWcoe1xuICBmb3JtYXRzLFxuICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gIG1lc3NhZ2VzLFxuICBvbkVycm9yLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IGZpbmFsT25FcnJvciA9IG9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XG4gIGNvbnN0IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrID0gZ2V0TWVzc2FnZUZhbGxiYWNrIHx8IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2s7XG4gIHtcbiAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIGZpbmFsT25FcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBmb3JtYXRzOiBmb3JtYXRzIHx8IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgdW5kZWZpbmVkLFxuICAgIG9uRXJyb3I6IGZpbmFsT25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrXG4gIH07XG59XG5cbmV4cG9ydCB7IEludGxFcnJvciBhcyBJLCBJbnRsRXJyb3JDb2RlIGFzIGEsIGNyZWF0ZUludGxGb3JtYXR0ZXJzIGFzIGIsIGNyZWF0ZUZvcm1hdHRlciBhcyBjLCBjcmVhdGVDYWNoZSBhcyBkLCBjcmVhdGVCYXNlVHJhbnNsYXRvciBhcyBlLCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIGFzIGYsIGRlZmF1bHRPbkVycm9yIGFzIGcsIGluaXRpYWxpemVDb25maWcgYXMgaSwgcmVzb2x2ZU5hbWVzcGFjZSBhcyByIH07XG4iXSwibmFtZXMiOlsiSW50bE1lc3NhZ2VGb3JtYXQiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsIm1lbW9pemUiLCJzdHJhdGVnaWVzIiwiSW50bEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJvcmlnaW5hbE1lc3NhZ2UiLCJtZXNzYWdlIiwiSW50bEVycm9yQ29kZSIsImNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdCIsImdsb2JhbEZvcm1hdHMiLCJpbmxpbmVGb3JtYXRzIiwidGltZVpvbmUiLCJtZkRhdGVEZWZhdWx0cyIsImZvcm1hdHMiLCJkYXRlIiwibWZUaW1lRGVmYXVsdHMiLCJ0aW1lIiwiZGF0ZVRpbWVGb3JtYXRzIiwiZGF0ZVRpbWUiLCJhbGxGb3JtYXRzIiwibnVtYmVyIiwiZm9yRWFjaCIsInByb3BlcnR5Iiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiam9pblBhdGgiLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsInByb3BzIiwibmFtZXNwYWNlIiwiZGVmYXVsdE9uRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJjcmVhdGVDYWNoZSIsInJlbGF0aXZlVGltZSIsInBsdXJhbFJ1bGVzIiwibGlzdCIsImRpc3BsYXlOYW1lcyIsImNyZWF0ZU1lbW9DYWNoZSIsInN0b3JlIiwiY3JlYXRlIiwiZ2V0Iiwic2V0IiwibWVtb0ZuIiwiZm4iLCJjYWNoZSIsInN0cmF0ZWd5IiwidmFyaWFkaWMiLCJtZW1vQ29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvckZuIiwiYXJncyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXROdW1iZXJGb3JtYXQiLCJOdW1iZXJGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwiZ2V0UmVsYXRpdmVUaW1lRm9ybWF0IiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwiZ2V0TGlzdEZvcm1hdCIsIkxpc3RGb3JtYXQiLCJnZXREaXNwbGF5TmFtZXMiLCJEaXNwbGF5TmFtZXMiLCJjcmVhdGVNZXNzYWdlRm9ybWF0dGVyIiwiaW50bEZvcm1hdHRlcnMiLCJnZXRNZXNzYWdlRm9ybWF0IiwiZm9ybWF0dGVycyIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJmdWxsS2V5Iiwic3BsaXQiLCJwYXJ0IiwibmV4dCIsInByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyIsInZhbHVlcyIsInRyYW5zZm9ybWVkVmFsdWVzIiwia2V5cyIsImluZGV4IiwidHJhbnNmb3JtZWQiLCJjaHVua3MiLCJyZXN1bHQiLCJnZXRNZXNzYWdlc09yRXJyb3IiLCJyZXRyaWV2ZWRNZXNzYWdlcyIsImludGxFcnJvciIsIk1JU1NJTkdfTUVTU0FHRSIsImdldFBsYWluTWVzc2FnZSIsImNhbmRpZGF0ZSIsInRlc3QiLCJ1bmRlZmluZWQiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNvbmZpZyIsIm1lc3NhZ2VzT3JFcnJvciIsImNyZWF0ZUJhc2VUcmFuc2xhdG9ySW1wbCIsImdldE1lc3NhZ2VGYWxsYmFjayIsIm9uRXJyb3IiLCJoYXNNZXNzYWdlc0Vycm9yIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJmYWxsYmFjayIsInRyYW5zbGF0ZUJhc2VGbiIsIl9mYWxsYmFjayIsImVycm9yTWVzc2FnZSIsIkFycmF5IiwiaXNBcnJheSIsIklOVkFMSURfTUVTU0FHRSIsIklOU1VGRklDSUVOVF9QQVRIIiwibWVzc2FnZUZvcm1hdCIsInBsYWluTWVzc2FnZSIsImxvY2FsZXMiLCJvcHRpb25zIiwidGhyb3duRXJyb3IiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZm9ybWF0IiwiU3RyaW5nIiwiRk9STUFUVElOR19FUlJPUiIsInRyYW5zbGF0ZUZuIiwicmljaCIsIm1hcmt1cCIsInJhdyIsImhhcyIsInJlc29sdmVOYW1lc3BhY2UiLCJuYW1lc3BhY2VQcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsIlNFQ09ORCIsIk1JTlVURSIsIkhPVVIiLCJEQVkiLCJXRUVLIiwiTU9OVEgiLCJRVUFSVEVSIiwiWUVBUiIsIlVOSVRfU0VDT05EUyIsInNlY29uZCIsInNlY29uZHMiLCJtaW51dGUiLCJtaW51dGVzIiwiaG91ciIsImhvdXJzIiwiZGF5IiwiZGF5cyIsIndlZWsiLCJ3ZWVrcyIsIm1vbnRoIiwibW9udGhzIiwicXVhcnRlciIsInF1YXJ0ZXJzIiwieWVhciIsInllYXJzIiwicmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQiLCJhYnNWYWx1ZSIsIk1hdGgiLCJhYnMiLCJjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZSIsInVuaXQiLCJyb3VuZCIsImNyZWF0ZUZvcm1hdHRlciIsIl9jYWNoZSIsIl9mb3JtYXR0ZXJzIiwiZ2xvYmFsVGltZVpvbmUiLCJhcHBseVRpbWVab25lIiwiRU5WSVJPTk1FTlRfRkFMTEJBQ0siLCJyZXNvbHZlRm9ybWF0T3JPcHRpb25zIiwidHlwZUZvcm1hdHMiLCJmb3JtYXRPck9wdGlvbnMiLCJvdmVycmlkZXMiLCJmb3JtYXROYW1lIiwiTUlTU0lOR19GT1JNQVQiLCJnZXRGb3JtYXR0ZWRWYWx1ZSIsImZvcm1hdHRlciIsImdldEZhbGxiYWNrIiwiZGF0ZVRpbWVSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZm9ybWF0UmFuZ2UiLCJnZXRHbG9iYWxOb3ciLCJub3ciLCJEYXRlIiwibm93T3JPcHRpb25zIiwibm93RGF0ZSIsIm9wdHMiLCJzdHlsZSIsIm51bWJlcmluZ1N5c3RlbSIsImRhdGVEYXRlIiwiZ2V0VGltZSIsIm51bWVyaWMiLCJzZXJpYWxpemVkVmFsdWUiLCJyaWNoVmFsdWVzIiwiTWFwIiwiaXRlbSIsInNlcmlhbGl6ZWRJdGVtIiwicHVzaCIsImZvcm1hdFRvUGFydHMiLCJtYXAiLCJ0eXBlIiwic2l6ZSIsInZhbGlkYXRlTWVzc2FnZXNTZWdtZW50IiwiaW52YWxpZEtleUxhYmVscyIsInBhcmVudFBhdGgiLCJtZXNzYWdlT3JNZXNzYWdlcyIsImluY2x1ZGVzIiwia2V5TGFiZWwiLCJ2YWxpZGF0ZU1lc3NhZ2VzIiwiSU5WQUxJRF9LRVkiLCJpbml0aWFsaXplQ29uZmlnIiwicmVzdCIsImZpbmFsT25FcnJvciIsImZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrIiwiSSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJpIiwiciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/use-intl@4.5.8_react@18.2.0/node_modules/use-intl/dist/esm/development/initializeConfig-CIDVMS2E.js\n");

/***/ })

};
;